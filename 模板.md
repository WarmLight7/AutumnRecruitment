



## 目录

[TOC]



## 1.整型二分

```C++
template <typename ForwardIt, typename T>
ForwardIt lower_bound(ForwardIt first, ForwardIt last, const T& value) {
    while (first != last) {
        ForwardIt mid = first + std::distance(first, last) / 2;
        if (*mid < value) {
            first = mid + 1;
        } else {
            last = mid;
        }
    }
    return first;
}

bool f(int mid)      
{  
    int sum=0,len=1;
    for(int i = 1;i < n;i++)  
    {  
        if((sum+(a[i] - a[i-1]))<mid) sum+=(a[i]-a[i-1]);  
        else  sum=0,len++; 
    }  
    if(len < m) return false;  
    else return true;  
}  
int main()
{
    int mid;  
    while(low<=high)  
    {  
        mid=(low+high)/2;  
        if(f(mid))low=mid+1;
        else high = mid-1;  
    }  
    return 0;
}
```



## 2.整浮点型二分

```C++
#define N 10086
const double eps = 1e-8;
int main()
{
    while(high-low>eps)
    {
        mid = (low+high)/2;
        if(f(mid)) high = mid;
        else low = mid;
    }
    return 0;
}
```



## 3.矩阵乘法，矩阵快速乘法

```c++
#define MAXV 70

typedef struct{
    int r,c;            //c行r列
    int mat[MAXV][MAXV];
}Matrix;

Matrix ans,cnt;
int n,k,m;

void Input(){
    int i,j;
    /*构造B矩阵*/
    memset(cnt.mat,0,sizeof(cnt.mat));
    memset(ans.mat,0,sizeof(ans.mat));
    for(i=0;i<n;i++){
        for(j=0;j<n;j++)
            scanf("%d",&cnt.mat[i][j]);
    }
    for(i=0;i<n;i++){
        cnt.mat[i+n][i+n]=cnt.mat[i][i+n]=1;
        ans.mat[i][i]=ans.mat[i+n][i+n]=1;
    }

    /*对矩阵B和B^（k+1）初始化*/
    cnt.c=cnt.r=2*n;
    ans.c=ans.r=2*n;

}

Matrix MatrixMul(Matrix x,Matrix y){    //矩阵乘法
    Matrix t;
    int i,j,v;
    memset(t.mat,0,sizeof(t.mat));
    t.c=x.c;
    t.r=y.r;

    for(i=0;i<t.c;i++)
        for(j=0;j<t.r;j++){
            for(v=0;v<x.r;v++)
                t.mat[i][j]+=((x.mat[i][v]*y.mat[v][j])%m);
            t.mat[i][j]=t.mat[i][j]%m;
        }
    return t;

}

void Binary(){
    //二分快速幂
    k++;
    while(k){
        if(k & 1) ans=MatrixMul(ans,cnt);
        cnt=MatrixMul(cnt,cnt);
        k=k>>1;
    }
}
int main(){
    while(~scanf("%d%d%d",&n,&k,&m))
    {
        Input();
        Binary();
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<n;j++)
                if(i!=j) printf("%d ",ans.mat[i][j+n]);
                else printf("%d ",ans.mat[i][j+n]-1);
            printf("\n");
        }
    }
    return 0;
}
```



## 4.最长上升子序列

```c++
int LIS(int A[],int n)
{
    int* d = new int[n];
    int len = 1;
    int i,j;
    for(i=0;i<n;i++)
    {
        d[i]=1;
        for(j=0;j<i;j++)
        {
            if(A[j]<=A[i] && (d[j]+1)>=d[i])
                d[i]=d[j]+1;
        }
        if(d[i]>len) len=d[i];
    }
    delete []d;
    return len;
}
```



## 5.最长公共子串


***

```C++
const int maxlen=1010;
char s1[maxlen],s2[maxlen];
int dp[maxlen][maxlen];    //dp[i][j]为串s1的前i个字符和串s2的前j个字符的最大公共子串长度
int main()
{
    int i,j;
    int len1,len2,ret;     //ret记录结果
    while(scanf("%s",s1)!=EOF)
    {
        scanf("%s",s2);
        memset(dp,0,sizeof(dp));   //初始化：开始LCS长度均为0
        len1=strlen(s1);
        len2=strlen(s2);
        ret=0;
        for(i=0;i<len1;i++)
        {
            for(j=0;j<len2;j++)
            {
                if(s1[i]==s2[j])
                    dp[i+1][j+1]=dp[i][j]+1;
                else
                    dp[i+1][j+1]=0;
                ret=max(ret,dp[i+1][j+1]);    //随时更新最大值
            }
        }
        printf("%d\n",ret);
    }
    return 0;
}
```



## 6.混合背包

***

```C++
int main()
{
	int v,n;
	while(scanf("%d%d",&v,&n)!=EOF)
	{
		int w[1000],c[1000],p[1000],i,k=0,t,j,f[202]={0};
		for(i=1;i<=n;i++)
		{
			t=1;
			scanf("%d%d%d",&w[i],&c[i],&p[i]);
			if(p[i]>1)   //将有限个相同价格的物品转化为不同价格的单个物品 
			{
				while(p[i]>t)
				{
					k++;
					w[n+k]=w[i]*t;
					c[n+k]=c[i]*t;
					p[n+k]=1;
					p[i]-=t;
					t*=2;
				}
				w[i]*=p[i];
				c[i]*=p[i];
				p[i]=1;
			}
		}
		for(i=1;i<=n+k;i++)
		 if(p[i]==1)   //判断是01背包还是完全背包 
		  for(j=v;j>=w[i];j--)
		   f[j]=f[j]>f[j-w[i]]+c[i] ? f[j]:f[j-w[i]]+c[i];
		 else
		  for(j=w[i];j<=v;j++)
		   f[j]=f[j]>f[j-w[i]]+c[i] ? f[j]:f[j-w[i]]+c[i];
		printf("%d\n",f[v]);
	}
	return 0;
}
```

***


## 7.仨背包拆开



```C++
    for(i=1;i<=m;i++)//0-1背包
    {  //尝试放置每一个物品
        for(j=t;j>=w[i];j--)
        {//倒叙是为了保证每个物品都使用一次
            f[j]=max(f[j-w[i]]+v[i],f[j]);
            //在放入第i个物品前后，检验不同j承重量背包的总价值，如果放入第i个物品后比放入前的价值提高了，则修改j承重量背包的价值，否则不变
        }
    }
for(int i=0; i<nKind; ++i)//多重背包
    for(int j=0; j<bag[i]; ++j)
        for(int k=nValue; k>=value[i]; --k)
            if(nMultiplePack[k] < nMultiplePack[k-value[i]]+weight[i])
                nMultiplePack[k] = nMultiplePack[k-value[i]] + weight[i];

        for(i=1; i<=n; i++)//完全背包
        {
            for(j=0; j<=c; j++)
            {
                for(int k=0; k*w[i]<=j; k++)
                    dp[i][j]=max(dp[i][j],dp[i-1][j-k*w[i]]+k*v[i]);//表示前i-1种物品中选取若干件物品放入剩余空间为j-k*w[i]的背包中所能得到的最大价值加上k件第i种物品的总价值；
            }
        }


```



## 8.快排


***

```C++
struct node
{
    char num[30];
    unsigned long long sum;
}a[1234];
bool cmp(const node &a,const node &b)
{
    if(a.sum!=b.sum)return a.sum < b.sum;
    return strcmp(a.num,b.num)<0?0:1;
}
sort(a+1,a+n+1,cmp);
struct node
{
    int star,ends,time;
    bool operator < (const node & I)const
    {
        if(ends != I.ends) return ends < I.ends;
        else return time < I.time;
    }
}a[200];
sort(a,a+n);
```



## 9.bfs


***

```C++
const int maxn=100;
bool vst[maxn][maxn]; // 访问标记
int dir[4][2]={0,1,0,-1,1,0,-1,0}; // 方向向量

struct State // BFS 队列中的状态数据结构
{
	int x,y; // 坐标位置
	int Step_Counter; // 搜索步数统计器
};


State a[maxn];
boolCheckState(State s) // 约束条件检验
{

	if(!vst[s.x][s.y] && ...) // 满足条件
		return 1;
	else // 约束条件冲突
	return 0;

}

void bfs(State st)
{
	queue <State> q; // BFS 队列
	State now,next; // 定义2 个状态，当前和下一个
	st.Step_Counter=0; // 计数器清零
	q.push(st); // 入队
	vst[st.x][st.y]=1; // 访问标记
	while(!q.empty())
	{
		now=q.front(); // 取队首元素进行扩展
		if(now==G) // 出现目标态，此时为Step_Counter 的最小值，可以退出即可
		{
			...... // 做相关处理
			return;
		}
	for(int i=0;i<4;i++)
	{
		next.x=now.x+dir[i][0]; // 按照规则生成	下一个状态
		next.y=now.y+dir[i][1];
		next.Step_Counter=now.Step_Counter+1; // 计数器加1
		if(CheckState(next)) // 如果状态满足约束条件则入队
		{
			q.push(next);
			vst[next.x][next.y]=1; //访问标记
		}
	}
	q.pop(); // 队首元素出队
	}
 return;
}

int main()
{
......
 return 0;
}
```



## 10.dfs



```C++
/*
该DFS 框架以2D 坐标范围为例，来体现DFS 算法的实现思想。
*/
const int maxn=100;
bool vst[maxn][maxn]; // 访问标记
int map[maxn][maxn]; // 坐标范围
int dir[4][2]={0,1,0,-1,1,0,-1,0}; // 方向向量，(x,y)周围的四个方向
bool CheckEdge(int x,int y) // 边界条件和约束条件的判断
{
	if(!vst[x][y] && ...) // 满足条件
		return 1;
	else // 与约束条件冲突
		return 0;
}

void dfs(int x,int y)
{
	vst[x][y]=1; // 标记该节点被访问过
	if(map[x][y]==G) // 出现目标态G
		{
		...... // 做相应处理
		return;
		}
	for(int i=0;i<4;i++)
	{
		if(CheckEdge(x+dir[i][0],y+dir[i][1])) // 按照规则生成下一个节点
			dfs(x+dir[i][0],y+dir[i][1]);
	}
	return; // 没有下层搜索节点，回溯
}
int main()
{
......
return 0;
}
```



## 11.hash


***

```C++
unsigned long long hash1[maxn],hash2[maxn],hash_l[maxn],base=2333333;
unsigned long long hashs[maxn];
char s1[maxn],s2[maxn];
void hash_init()
{
    unsigned long long val=0;hash_l[0]=1;
    for(int i = 1; i <= len1 ; i++)
    {
        val = val * base + s1[i]-'0';
        hash1[i]=val;
    }
    val=0;
    for(int i=1;i<=len2;i++)
    {
        val=val*base+s2[i]-'0';
        hash2[i]=val;
    }
    int maxx=max(len1,len2);
    for(int i=1;i<=maxx;i++)
        hash_l[i]=hash_l[i-1]*base;
}
```



## 12.单调栈

***

```C++
long long a[maxn],stacks[maxn],left[maxn];
    int top = 0;
    for (int i = 1;i <= N;i++)
    {
        if (!top || a[i] > a[stacks[top-1]])
        {
            stacks[top++] = i;
            left[i] = i;
            continue;
        }
        if (a[i] == a[stacks[top-1]])continue;
        while (top > 0 && a[i] < a[stacks[top-1]])
        {
            top--;
            tmp = a[stacks[top]]*((i-1)- (left[stacks[top]]-1));
            res = max(tmp,res);
        }
        tmp = stacks[top];
        stacks[top++] = i;
        left[i] = left[tmp];
    }
```



## 13.单调队列

***

```C++
int n,m,l=1,r=1,ans=9999999,f[100001],a[100001],t[100001];
int main()
{
    for(int i=1;i<=n;i++)
        cin>>a[i];
    for(int i=1;i<=n;i++)
    {
        while(l<=r&&i-t[l]>m)l++;
        f[i]=f[t[l]]+a[i];
        while(l<=r&&f[t[r]]>f[i])r--;
        t[++r]=i;
    }   
    for(int i=n-m+1;i<=n;i++)
        ans=min(ans,f[i]);
}
```



## 14.尺取法



```C++
void worm_solve()
{
    int res=MAX;
    int s=0,t=0,sum=0;
    for(;;)
     {
      while(t<n && sum < S){
         sum+=a[t++];
        }
     if(sum<S) break;
     res=min(res,t-s);
     sum-=a[s++];
}
   if(res>n)
   {
    res=0;
 }
 printf("%d\n",res);
}
```



## 15.并查集找爸爸


***

```C++
int flag[N], father[N];
int Find(int x)
{
    if(x != father[x]) father[x] = Find(father[x]);
    return father[x];
}
void Merge(int a, int b)
{
    int p = Find(a);
    int q = Find(b);
    if(p > q) father[p] = q;
    else father[q] = p;
}
void init(int n)
{
    for(int i = 1 ; i <= n; i++)fa[i] = i;
}
int main()
{
    int a,b,FLAG=0;
    while(1)
    {
        if(a == 0 && b == 0)  break;
        if(Find(a) == Find(b)) FLAG = 1;
        Merge(a,b);
        flag[a] = 1, flag[b] = 1;
        scanf("%d%d",&a,&b);
    }
    return 0;
}
```



## 16.带权并查集


***

```C++
const int maxn = 200011;
int n, m, fa[maxn], dis[maxn];
void init()
{
    for(int i = 0; i <= n; i++)
        fa[i] = i, dis[i] = 0;
}
int find(int x)
{
    if(fa[x] == x)
        return x;
    int t = fa[x];
    fa[x] = find(fa[x]);
    dis[x] += dis[t];
    return fa[x];
}
void Union(int u,int v,int x)
{
    int ru = find(u);
    int rv = find(v);
    fa[rv] = ru;
    dis[rv] = dis[u] + x - dis[v];
}
int main()
{
    while(scanf("%d%d",&n,&m)!=EOF)
    {
        init();
        int u, v, dist, ans = 0;
        while(m--)
        {
            scanf("%d%d%d",&u,&v,&dist);
            if(find(u) != find(v))Union(u,v,dist);
            else if(dis[u] + dist != dis[v])ans++;
        }
        printf("%d\n",ans);
    }
    return 0;
}
```



## 17.最小生成树


***

```C++
int set[110];
struct record
{
    int beg;
    int end;
    int money;
}s[11000];
int find(int fa)
{
    int ch=fa;
    int t;
    while(fa!=set[fa])
    fa=set[fa];
    while(ch!=fa)
    {
        t=set[ch];
        set[ch]=fa;
        ch=t;
    }
    return fa;
}
void mix(int x,int y)
{
    int fx,fy;
    fx=find(x);
    fy=find(y);
    if(fx!=fy)
    set[fx]=fy;
}
bool cmp(record a,record b)
{
    return a.money<b.money;
}
int main()
{
    int city,road,j,i,sum;
    while(scanf("%d",&road)&&road!=0)
    {
        scanf("%d",&city);
        for(i=0;i<road;i++)
        {
            scanf("%d%d%d",&s[i].beg,&s[i].end,&s[i].money);
        }
        for(i=1;i<=city;i++)
        set[i]=i;
        sort(s,s+road,cmp);
        sum=0;
        for(i=0;i<road;i++)
        {
            if(find(s[i].beg)!=find(s[i].end))
            {
                mix(s[i].beg,s[i].end);
                sum+=s[i].money;
            }
        }
        j=0;
        for(i=1;i<=city;i++)
        {
            if(set[i]==i)
            j++;
            if(j>1)
            break;
        }
        if(j>1)
        printf("?\n");
        else
        printf("%d\n",sum);
    }
    return 0;
}
```



## 18.邻接表建图


***

```C++
int tot = 1;
int head[maxn];
int flag[maxn];
int times[maxn], colors[maxn];
struct node
{
    int v, next;
    //edge[i].v 表示编号为i的边是一条指向节点v的边
    //edge[i].w 表示编号为i的边所带有的权值
    //edge[i].next 表示编号为i的边是一条u->v的边的下一条边
}edge[maxn * 2 + 2];

void addedge(int ui, int vi)
{
    //建立单向的节点u->v
    edge[tot].v = vi;
    edge[tot].next = head[ui];
    head[ui] = tot++;

    edge[tot].v = ui;
    edge[tot].next = head[vi];
    head[vi] = tot++;

}
//查询所有与某节点相连的节点

//for(int i = head[x]; i != 0; i = edge[i].next)
```



## 19.基于邻接矩阵的最短路spfa


***

```C++
int d[N],v[N],mp[N][N],n;
int spfa(int s,int t)
{
    for(int i=0;i<=n;i++)   d[i]=INF,v[i]=0;
    queue<int> q;
    q.push(s);
    d[s]=0;
    v[s]=1;
    while(!q.empty())
    {
        int c=q.front();
        q.pop();
        v[c]=0;
        for(int i=0;i<n;i++)
        {
            if(d[i]>d[c]+mp[c][i]&&mp[c][i] < INF)
            {
                d[i]=d[c]+mp[c][i];
                if(!v[i])v[i]=1,q.push(i);
            }
        }
    }
    if(d[t]>=INF)   return -1;
    return d[t];
}

int main()
{
    int m;
    while(~scanf("%d%d",&n,&m))
    {
        for(int i=0;i<=n;i++)
            for(int j=0;j<=n;j++)
                mp[i][j]=INF;
        for(int i=0;i<m;i++)
        {
            int u,v,w;
            scanf("%d%d%d",&u,&v,&w);
            mp[u][v]=min(mp[u][v],w);
            mp[v][u]=min(mp[v][u],w);
        }
        int beg ,ed;
        scanf("%d %d",&beg,&ed);
        printf("%d\n",spfa(beg,ed));
    }
}
```



## 20.基于邻接矩阵的最短路dijkstra


***

```C++
void dijkstra(int s)  
{  
    memset(vis,0,sizeof(vis));         
    int cur=s;                     
    dis[cur]=0;  
    vis[cur]=1;  
    for(int i=0;i<n;i++)  
    {  
       for(int j=0;j<n;j++)                       
            if(!vis[j] && dis[cur] + map[cur][j] < dis[j])   //未被标记且比已知的短，可更新  
                dis[j]=dis[cur] + map[cur][j] ;  

        int mini=INF;  
        for(int j=0;j<n;j++)                    
            if(!vis[j] && dis[j] < mini)    //选择下一次到已知顶点最短的点。  
                mini=dis[cur=j];  
        vis[cur]=true;  

   }     
} 
```



## 21.基于邻接表的最短路spfa


***

```C++
void spfa(int s)  
{  
    memset(vis,0,sizeof(vis));  
    for(int i=0;i<n;i++)  
        dis[i]=INF;   

    queue<int> q;  
    q.push(s);  
    vis[s]=true;  
    dis[s]=0;  
    while(!q.empty())  
    {  
        int cur=q.front();  
        q.pop();  
        vis[cur]=false;  
        for(int i=head[cur];i!=-1;i=e[i].next)  
        {  
            int id=e[i].to;  
            if(dis[id] > dis[cur]+e[i].val)  
            {  
                dis[id] = dis[cur] + e[i].val;  
                if(!vis[id])  
                {  
                    vis[id]=true;  
                    q.push(id);  
                }  
            }  
        }  
    }  

} 
```



### Floyd模板


***

```C++
#include <cstdio>
#include <cstring>
#define INF 0x3f3f3f3f
using namespace std;
// 最大顶点数
const int MAXN = 1000;
// 邻接矩阵的定义
// mat[i][j] 表示 顶点`i`到顶点`j`的权值

int mat[MAXN][MAXN];
int N,M;
// floyd算法
void floyd()
{
    for(int k = 1 ; k <= N ; k++)
        for(int i = 1 ; i <= N ; i++)
            for(int j = 1 ; j <= N ; j++)
                if(mat[i][j] > mat[i][k] + mat[k][j])
                    mat[i][j] = mat[i][k] + mat[k][j];
}
int main()
{
    // 邻接矩阵的初始化操作
    // 假设权值为零表示没有该边
    memset(mat,INF, sizeof(mat));
    for(int i = 0 ; i < MAXN ; i++)
        mat[i][i] = 0;
    // 假设有n个点m条边
    scanf("%d %d",&N,&M);
    // 增加边
    // 新增顶点`i`到顶点`j`的边，权值为`w`
    for(int k = 0 ; k < M ; k++)
    {
        int i,j,w;
        scanf("%d %d %d",&i,&j,&w);
        mat[i][j] = w;
        mat[j][i] = w;
    }
    // 图的遍历
    for(int i = 1 ; i <= N ; i++)
    {
        for(int j = 1 ; j <= N ; j++)
        {
            if(mat[i][j] != INF)
                printf("%3d",mat[i][j]);
            else
                printf("INF");
            if(j == N)printf("\n");
            else printf(" ");
        }
    }
    printf("\n\n\n");
    floyd();
    //打印图中各点距离
    for(int i = 1 ; i <= N ; i++)
    {
        for(int j = 1 ; j <= N ; j++)
        {
            if(mat[i][j] != INF)
                printf("%3d",mat[i][j]);
            else
                printf("INF");
            if(j == N)printf("\n");
            else printf(" ");
        }
    }
    return 0;
}
    // 删除边
    // 删除顶点`i`到顶点`j`的边
    //mat[i][j] = 0;
    // 查询边
    // 查询顶点`i`到顶点`j`的边权
    //mat[i][j];
```



### 单源最短路

```C++
#include <cstring>
#include <cstdio>
#include <queue>
#define INF 0x3f3f3f
using namespace std;
// 最大顶点数
const int MAXN = 1000;
// 最大边数
const int MAXM = 1000;
// 边结构体的定义
struct Edge
{
    int to;         // 表示这条边的另外一个顶点
    int next;       // 指向下一条边的数组下标，值为-1表示没有下一条边
    int w;          //表示这条边的权值
};

Edge edge[MAXM];
// head[i] 表示顶点`i`的第一条边的数组下标，-1表示顶点`i`没有边
int head[MAXN];
int M,N,num = 0;
int dist[MAXN];
bool vist[MAXN];
// dijkstra算法
struct HeapNode
{
    int dist,u;
    bool operator < (const HeapNode& rhs)const{
        return dist > rhs.dist;
    }
};

void dijkstra(int s)
{
    priority_queue<HeapNode> Q;
    for(int i = 1 ; i <= N ; i++)dist[i] = INF;
    dist[s] = 0;
    memset(vist,false,sizeof(vist));
    Q.push((HeapNode){0,s});
    while(!Q.empty())
    {
        HeapNode x = Q.top();Q.pop();
        int u = x.u;
        if(vist[u])continue;
        vist[u] = true;
        for(int i = head[u] ; i != -1 ;i = edge[i].next)
        {
            if(dist[edge[i].to] > dist[u]+edge[i].w)
            {
                dist[edge[i].to] = dist[u]+edge[i].w;
                Q.push((HeapNode){dist[edge[i].to],edge[i].to});
            }
        }
    }
}
// SPFA算法（优化的Bellman-Ford算法）
int cnt[MAXN];
int pre[MAXN];
bool SPFA(int s)
{
    queue<int>Q;
    memset(vist,0,sizeof(vist));
    memset(cnt ,0, sizeof(cnt));
    for(int i = 1 ; i <= N ; i++)dist[i] = INF,pre[i] = i;
    dist[s] = 0;
    vist[s] = true;
    Q.push(s);
    while(!Q.empty())
    {
        int u = Q.front();Q.pop();
        vist[u] = false;
        for(int i = head[u] ; i != -1 ; i = edge[i].next)
        {
            if(dist[u] < INF && dist[edge[i].to] > dist[u] + edge[i].w)
            {
                dist[edge[i].to] = dist[u] + edge[i].w;
                pre[edge[i].to] = i;
                if(!vist[edge[i].to])
                {
                    Q.push(edge[i].to);
                    vist[edge[i].to] = true;
                    if(++cnt[edge[i].to] > N)
                        return false;
                }
            }
        }
    }
    return true;
}
// 增加边的方式
// 新增边 a -> b，该边的数组下标为`k`
inline void AddEdge(int a, int b, int w)
{
    edge[num].to = b;
    edge[num].w = w;
    edge[num].next = head[a];    // 新增的边要成为顶点`a`的第一条边，而不是最后一条边
    head[a] = num++;
    edge[num].to = a;
    edge[num].w = w;
    edge[num].next = head[b];    // 新增的边要成为顶点`b`的第一条边，而不是最后一条边
    head[b] = num++;
    return;
}

int main()
{
    // 链式前向星初始化，只需要初始化顶点数组和num的值
    memset(head, -1, sizeof(head));
    num = 0;
     // 假设有n个点m条边
    scanf("%d %d",&N,&M);
    // 增加边
    // 新增顶点`i`到顶点`j`的边，权值为`w`
    for(int l = 0 ; l < M ; l++)
    {
        int i,j,w;
        scanf("%d %d %d",&i,&j,&w);
        AddEdge(i,j,w);
    }
    // 实现图的遍历
    for(int i = 1 ; i <= N ; i++)
    {
        for (int j=head[i]; j!=-1; j=edge[j].next)
        {
            // edge[j] 就是你当前遍历的边 i -> edge[j].to
             printf("%d %d %d\n",i,edge[j].to,edge[j].w);
        }
    }
    printf("\n\n\n");
    // 打印图中所有点到各个点的距离
    for(int i = 1 ; i <= N ; i++)
    {
        dijkstra(i);
        //SPFA(i);
        for(int j = 0 ; j <= N ; j++)
            if(dist[j] != INF)
                printf("%3d %3d %3d\n",i,j,dist[j]);
            else
                printf("%3d %3d INF\n",i,j);
    }
    return 0;
}
```



## 22.快速幂&&快速乘

***

```C++
ll quick_pow(ll a,ll b,ll p)
{
    a%=p;
    ll res = 1;
    while(b)
    {
        if(b&1)res=res*a,res%=p;
        a*=a;a%=p;
        b>>=1;
    }
    return res;
}
ll fast_multi(ll m,ll n, ll mod)
{
    ll ans = 0;
    while(n)
    {
        if(n&1)
            ans+=m;
        m = (m+m)%mod;
        m%=mod;
        ans%=mod;
        n>>=1;
    }
    return ans;
}
```



## 23.求逆元和阶乘对于单个数的逆元quickpow（n,p-2,p）


***

```C++
void init(){
    fac[0]=1;
    for(ll i=1;i<maxn;i++)  fac[i]=fac[i-1]*i%mod;
    inv[maxn-1]=quickpower(fac[maxn-1],mod-2); 
    for(ll i=maxn-2;i>=0;i--)   inv[i]=inv[i + 1]*(i + 1)%mod;
}
```



## 24. Lucas定理求C(n, m) % p


***

```C++
typedef long long llg;
const int N =150000;
llg n, m, p, fac[N];
void init()
{
    int i;
    fac[0] =1;
    for(i =1; i <= p; i++)
        fac[i] = fac[i-1]*i % p;
}
llg quick_mod(llg a, llg b)
{
    llg tmp = a % p, ans =1;
    while(b)
    {
        if(b &1)  ans = ans * tmp % p;
        tmp = tmp*tmp % p;
        b >>=1;
    }
    return  ans;
}
llg C(llg n, llg m)
{
    if(m > n)  return 0;
    return  fac[n]*quick_mod(fac[m]*fac[n-m], p-2) % p;
}
llg Lucas(llg n, llg m)
{
    if(m ==0)  return 1;
    else return  (C(n%p, m%p)*Lucas(n/p, m/p))%p;
}
int main()
{
    int t;
    scanf("%d", &t);
    while(t--)
    {
        scanf("%I64d%I64d%I64d", &n, &m, &p);
        init();
        printf("%I64d\n", Lucas(n+m, m));
    }
    return 0;
}
```



## 25.Lucas定理求C(n, m) % p当p为大素数的时候


***

```C++
LL n,m,p;

LL quick_mod(LL a, LL b)
{
    LL ans = 1;
    a %= p;
    while(b)
    {
        if(b & 1)
        {
            ans = ans * a % p;
            b--;
        }
        b >>= 1;
        a = a * a % p;
    }
    return ans;
}

LL C(LL n, LL m)
{
    if(m > n) return 0;
    LL ans = 1;
    for(int i=1; i<=m; i++)
    {
        LL a = (n + i - m) % p;
        LL b = i % p;
        ans = ans * (a * quick_mod(b, p-2) % p) % p;
    }
    return ans;
}

LL Lucas(LL n, LL m)
{
    if(m == 0) return 1;
    return C(n % p, m % p) * Lucas(n / p, m / p) % p;
}

int main()
{
    int T;
    scanf("%d", &T);
    while(T--)
    {
        scanf("%I64d%I64d%I64d", &n, &m, &p);
        printf("%I64d\n", Lucas(n,m));
    }
    return 0;
}
```



## 26.中国剩余定理 Lucas定理求C(n, m) % (∏pi)

***

```C++
ll prim[N+100],B[N+100];
ll fac[N+100];
void init (ll p)
{
    fac[0] = 1;
    for(int i = 1 ; i <= p;i++)
        fac[i] = (fac[i-1]*i)%p;
}
ll quick_pow(ll a,ll b,ll p)
{
    a%=p;
    ll res = 1;
    while(b)
    {
        if(b&1)res=res*a,res%=p;
        a*=a;a%=p;
        b>>=1;
    }
    return res;
}
ll C(ll n,ll m,ll p)
{
    if(m>n)return 0;
    return fac[n]*quick_pow(fac[m],p-2,p)%p*quick_pow(fac[n-m],p-2,p)%p;
}
ll lucas(ll n,ll m,ll p)
{
    if(!m)return 1;
    return (C(n%p,m%p,p)*lucas(n/p,m/p,p))%p;
}
ll exgcd(ll a,ll b,ll &x, ll &y)
{
    ll d;
    if(b==0)
    {
        x=1;
        y=0;
        return a;
    }
    d=exgcd(b,a%b,y,x);
    y-=a/b*x;
    return d;
}
ll fast_multi(ll m,ll n, ll mod)
{
    ll ans = 0;
    while(n)
    {
        if(n&1)
            ans+=m;
        m = (m+m)%mod;
        m%=mod;
        ans%=mod;
        n>>=1;
    }
    return ans;
}
ll CTF(ll b[], ll w[] , ll len)
{
    ll i,d,x,y,m,n,ret;
    ret = 0;n = 1;
    for(i = 0 ;i < len ; i++)n*=w[i];
    for(i=0;i<len;i++)
    {
        m=n/w[i];
        d=exgcd(w[i],m,x,y);
        ll re = fast_multi(y,m,n);
        re=fast_multi(re,b[i],n);
        ret+=re;
        re%=n;
    }
    return (n+ret%n)%n;
}
int main()
{
    int t;
    scanf("%d",&t);
    while(t--)
    {
        ll n,m;
        int k;
        scanf("%I64d%I64d%d",&n,&m,&k);
        for(int i = 0 ; i < k ; i++)
        {
            scanf("%I64d",&prim[i]);
            init(prim[i]);
            B[i] = lucas(n,m,prim[i]);
        }
        printf("%I64d\n",CTF(B,prim,k));
    }
    return 0;
}
```



## 27.Catalan数求法大数储存h（n） = h（n-1）*（4n-2）/（n+1）


***

```C++
#include <iostream>
#include <stdio.h>
using namespace std;
int a[105][100];
void catalan()
{
    int i,j,yu,len;
    a[2][0]=a[1][0]=a[1][1]=1;
    a[2][1]=2; len = 1;
    for(i=3;i<101;i++)
    {
        yu = 0;
        for(j=1;j<=len;j++)
        {
            int t=(a[i-1][j])*(4*i-2)+yu;
            yu=t/10;
            a[i][j]=t%10;
        }
        while(yu)
        {
            a[i][++len]=yu%10;
            yu/=10;
        }
        for(j=len;j>=1;j--)
        {
            int t=a[i][j]+yu*10;
            a[i][j]=t/(i+1);
            yu= t%(i+1);
        }
        while(!a[i][len])len--;
        a[i][0] = len;
    }
}
int main()
{
    catalan();
    int n;
    while(~scanf("%d",&n))
    {
        for(int i = a[n][0];i>0;i--)
        {
            printf("%d",a[n][i]);
        }
        printf("\n");
    }
    return 0;
}
```



## 28.欧拉函数（求不大于他与他互质的数的个数）

***

```C++
typedef long long ll;
ll euler(ll n)
{
    ll ans = n;
    for(int i = 2 ; i * i <= n ; i++)
    {
        if(n%i == 0)
        {
            ans =  ans/i * (i-1);
            while(n % i == 0) n/= i;
        }
    }
    if(n>1) ans = ans / n * (n - 1);
    return ans;
//原根个数=euler(n-1)
```



## 29.原根求法


***

```C++
typedef __int64 LL;
const int MAXN = 1005;
int prim[MAXN], nprm;
bool vis[MAXN];
int n, m;
void init_prim()
{
    for (int i = 2; i< MAXN; ++i)
    {
        if (!vis[i]) prim[nprm++] = i;
        for (int j = 0; j< nprm && prim[j]&i < MAXN; ++i)
        {
            vis[prim[j]*i] = 1;
            if (i % prim[j] == 0) break;
        }
    }
}
int Euler(int x)
{
    int res = x;
    for (int i = 0, k; i< nprm ; ++i)
    {
        k = prim[i];
        if (k * k > x) break;
        if (x % k == 0)
        {
            res = res/k*(k-1);
            while (x%k==0) x/=k;
        }
    }
    if (x!=1) res = res/x*(x-1);
    return res;
}
int nfen, fen[100][2];
void m_divide(int x)
{
    nfen = 0;
    for (int i = 0, k; i< nprm ; ++i)
    {
        k = prim[i];
        if (k * k > x) break;
        if (x % k == 0)
        {
            fen[nfen][0] = k;
            fen[nfen][1] = 0;
            while (x%k==0) x/=k, ++fen[nfen][1];
            ++nfen;
        }
    }
    if (x!=1) fen[nfen][0]=x, fen[nfen++][1]=1;
}
LL mpow(LL a, int b, LL mod)
{
    LL res = 1LL;
    while (b)
    {
        if (b&1) res = res*a%mod;
        a = a*a%mod;
        b >>= 1;
    }
    return res;
}
int caonima = 0;
LL ri;
void dfs(int idx, LL all)
{
    if (caonima) return;
    if (idx == nfen)
    {
        if (all == 1LL || all == m) return;
        if (mpow(ri, all, n) == 1LL)
            caonima = 1;
        return;
    }
    for (int i = 0; i<=fen[idx][1]; ++i)
    {
        dfs(idx+1, all);
        all *= fen[idx][0];
    }
}
int check(LL r)
{
    LL res = r;
    if (mpow(r, m, n) != 1LL) return 0;
    caonima = 0;
    ri = res;
    dfs(0, 1);
    if (caonima) return 0;
    return 1;
}

int gcd(int a, int b)
{
    return b==0?a:gcd(b,a%b);
}
int opt[1000000], cnt;
void solve()
{
    m = Euler(n);
    m_divide(m);
    int ff = 0;
    for (int i = 2; i< n; ++i)
    {
        if (check(i))
        {
            ff = i;
            break;
        }
    }
    if (!ff)
    {
        printf("-1\n");
        return;
    }
    cnt = 0;
    opt[cnt++] = ff;
    LL res = ff;
    res = res*ff%n;
    for (int i = 2; i< m; ++i, res = res*ff%n)
    {
        if (gcd(i, m) == 1)
        {
            opt[cnt++] = res;
        }
    }
    sort(opt, opt+cnt);
    printf("%d", opt[0]);
    for (int i = 1; i< cnt; ++i)
    {
        printf(" %d", opt[i]);
    }
    puts("");
}
int main()
{
    init_prim();
    while (scanf("%d", &n) != EOF)
    {
        if (n==2) puts("1");
        else if (n==4) puts("3");
        else
        {
            int p = n, cc = 0;
            if (n%2==0) n>>=1;
            for (int i = 0, k; i<nprm ; ++i)
            {
                k = prim[i];
                if (k*k > n) break;
                if (n % k == 0)
                {
                    if (++cc > 1) break;
                    while (n % k==0) n /= k;
                }
            }
            if (n!=1) ++cc;
            if (cc!=1) puts("-1");
            else
            {
                n = p;
                solve();
            }
        }
    }
    return 0;
}
```

## 30.数根公式


***

```C++
digital root = 1 + ((num - 1) % 9)
```



## 31.素数筛法


***

```C++
int prime[MAXN+1];

bool st[N];
int getPrime()
{
    memset(prime,0,sizeof(prime));
    for(int i=2;i<=MAXN;i++)
    {
        if(!prime[i]) prime[++prime[0]]=i;
        for(int j=1;j<=prime[0]&&prime[j]<=MAXN/i;j++)
        {
            prime[prime[j]*i]=1;
            st[primes[j] * i] = true;
            if(i%prime[j]==0) break;
        }
    }
    return prime[0];
}
```



## 32.exgcd

***

```C++
typedef long long ll;

ll exgcd( ll a, ll b, ll& x, ll& y )
{
    if(b == 0)
    {
        x = 1;
        y = 0;
        return a;
    }
    ll gcd = exgcd( b, a%b, x, y );
    ll tem = x;
    x = y;
    y = tem - a / b*y;
    return gcd;
}
int gcd ( int a , int b )
{
    return b == 0 ? a : gcd ( b , a % b ) ;
}
```

## 33.BSGS(已知A, B, C，求X使得A^x = B (mod C))


***

```C++
const int MOD = 76543;
int hs[MOD],head[MOD],Next[MOD],id[MOD],top;
void Insert(int x,int y)
{
    int k = x%MOD;
    hs[top] = x,id[top] = y,Next[top] = head[k],head[k] = top++;
}
int Find(int x)
{
    int k = x%MOD;
    for(int i = head[k]; i!= -1 ; i = Next[i])
        if(hs[i] == x)
        return id[i];
    return -1;
}
int BSGS(int a,int b,int n)
{
    memset(head,-1,sizeof(head));
    top = 1;
    if(b==1)return 0;
    int m = sqrt(n*1.0),j;
    long long x = 1,p = 1;
    for(int i = 0 ; i < m ; i++,p=p*a%n)Insert(p*b%n,i);
    for(long long i = m ; ;i+=m)
    {
        if((j = Find(x = x*p%n))!=-1)return i-j;
        if(i > n)break;
    }
    return -1;
}
```



## 34.KMP

***

```C++
int next[1000005];
void get_next(char c[])
{
    int n = strlen(c);
    int i=0,j=-1;
    next[0] = -1;
    while(i < n)
    {
        if(c[i] == c[j] || j == -1)
        {
            i++;j++;next[i] = j;
        }
        else j = next[j];
    }
}
int kmp(char str1[], char str2[])
{
    int i = 0 ,j = 0;
    int len1 = strlen(str1),len2 = strlen(str2);
    get_next(str2);
    while(i<len1&&j<len2)
    {
        if(j == -1 || str1[i] == str2[j])
        {
            i++;j++;
        }
        else
            j = next[j];
    }
    if(i == len1)
        return j;
    return 0;
}
```



## 35.exKMP


***

```C++
#include <bits/stdc++.h>
const int maxn = 100010;//字符串的最大长度
using namespace std;
int next[maxn],exend[maxn];
void GetNext(char *str)
{
    int i = 0, j ,po,len = strlen(str);
    next[0] = len;
    while(str[i] == str[i+1] &&i+1<len)i++;
    next[1] = i;
    po = 1;
    for(i = 2 ; i < len ; i++)
    {
        if(next[i-po]+i<next[po]+po)
            next[i] = next[i-po];
        else
        {
            j = next[po]+po-i;
            if(j<0)j = 0;
            while(i+j<len&&str[j]==str[j+i])j++;
            next[i] = j;
            po=i;
        }
    }
}
void Getnext(char *str)
{
    int i = 0 ,j = -1,len = strlen(str);next[0] = -1;
    while(i<len){
        if(j == -1 ||str[i]==str[j]){
            next[++i]=++j;
            next[i] = str[i]!=str[j]?j:next[j];
        }
        else j = next[j];
    }
}
void kmp(char *str1 ,char *str2)
{
    int i = 0 ,j = 0,len1=strlen(str1),len2=strlen(str2);
    while(i!=len1)
        {
        if(j == -1||str1[i]==str2[j]) ++i,++j;
        else j = next[j];
        if(j == len2)
        {
            //ans++;
            j = next[j];
        }
    }
}
//计算extend
void EXkmp(char *s1,char *s2)
{
    int i = 0 , j,po,len1=strlen(s1),len2=strlen(s2);
    GetNext(s2);
    while(s1[i]==s2[i]&&i<len2&&i<len1)i++;
    exend[0] = i;
    po=0;
    for(i = 0 ; i < len1 ; i++)
    {
        if(next[i-po]+i<exend[po]+po)
            exend[i] = next[i-po];
        else
        {
            j = exend[po]+po-i;
            if(j<0)j=0;
            while(i+j<len1&&j<len2&&s1[j+i]==s2[j])j++;
            exend[i]=j;
            po=i;
        }
    }
}
int main()
{

    return 0;

}

//预处理计算Next数组
void getNext(char str[])
{
    int i=0,j,po,len=strlen(str);
    Next[0]=len; //初始化next[0]
    while(str[i]==str[i+1] && i+1<len) i++; Next[1]=i; //计算next[1]
    po=1; //初始化po的位置
    for(i=2;i<len;i++)
    {
        if(Next[i-po]+i < Next[po]+po) //第一种情况，可以直接得到next[i]的值
            Next[i]=Next[i-po];
        else //第二种情况，要继续匹配才能得到next[i]的值
        {
            j = Next[po]+po-i;
            if(j<0) j=0; //如果i>po+next[po],则要从头开始匹配
            while(i+j<len && str[j]==str[j+i]) j++; Next[i]=j;
            po=i; //更新po的位置
        }
    }
}

//计算extend数组
void EXKMP(char s1[],char s2[])
{
    int i=0,j,po,len=strlen(s1),l2=strlen(s2);
    getNext(s2); //计算子串的next数组
    while(s1[i]==s2[i] && i<l2 && i<len) i++; extend[0]=i;
    po=0; //初始化po的位置
    for(i=1;i<len;i++)
    {
        if(Next[i-po]+i < extend[po]+po) //第一种情况，直接可以得到extend[i]的值
            extend[i]=Next[i-po];
        else //第二种情况，要继续匹配才能得到extend[i]的值
        {
            j = extend[po]+po-i;
            if(j<0) j=0; //如果i>extend[po]+po则要从头开始匹配
            while(i+j<len && j<l2 && s1[j+i]==s2[j]) j++; extend[i]=j;
            po=i; //更新po的位置
        }
    }
}
```



## 36.manacher

***

```C++
void manacher(char* s)
{
    int len = strlen(s),id = 0,maxr = 0;
    P[0] = 0;
    for(int i = 1 ; i < len ; i++)
    {
        if(maxr > i)
            P[i] = min(P[2*id-i],maxr-i);
        else
            P[i] = 1;
        while(s[i+P[i]] == s[i-P[i]])P[i]++;
        if(maxr < P[i]+i)
        {
            maxr = P[i] +i;
            id = i;
        }
    }
}
```



## 37.强联通分量SCC


***

```C++
const int maxn = 100002;
struct Node
{
    int to;
    int next;
}edge[maxn * 10];
int m,n;
int head[maxn];
int dfn[maxn];
int low[maxn];
int Stack[maxn];
int belong[maxn];
int indegree[maxn],outdegree[maxn];
bool vis[maxn];
int cou,time,belongcnt,top;
int sum[maxn];
void init()
{
    cou = 0;time = 1;belongcnt=0;top = 0;
    memset(head,-1,sizeof(head));
    memset(belong,0,sizeof(belong));
    memset(indegree,0,sizeof(indegree));
    memset(outdegree,0,sizeof(outdegree));
    memset(dfn,0,sizeof(dfn));
    memset(low,0,sizeof(low));
    memset(vis,false,sizeof(vis));
    memset(sum,0,sizeof(sum));
    memset(edge,0,sizeof(edge));
    memset(Stack,0,sizeof(Stack));
}
void add_edge(int u,int v)
{
    edge[cou].to = v;
    edge[cou].next = head[u];
    head[u] = cou++;
}
void targan(int u)
{
    low[u] = dfn[u] = time;
    time++;
    vis[u] = true;
    Stack[top++] = u;
    for(int i = head[u] ; i!= -1;i = edge[i].next)
    {
        int v = edge[i].to;
        if(!dfn[v])
        {
            targan(v);
            low[u] = min(low[u],low[v]);
        }
        else if(vis[v])
            low[u] = min(low[u],dfn[v]);
    }
    if(low[u] == dfn[u])
    {
        belongcnt++;
        while(top>0&&Stack[top]!=u)
        {
            top--;
            vis[Stack[top]] = false;
            belong[Stack[top]] = belongcnt;
            sum[belongcnt]++;
        }
    }
}
int main()
{
    int T;
    scanf("%d",&T);
    for(int cas = 1 ; cas <= T ; cas++)
    {
        init();
        int u,v;
        scanf("%d%d",&n,&m);
        for(int i = 1 ; i <= m ; i++)
        {
            scanf("%d%d",&u,&v);
                add_edge(u,v);
        }
        for(int i = 1 ; i <= n ;i++)
            if(!dfn[i])
                targan(i);
        if(belongcnt == 1)
        {
            printf("Case %d: -1\n",cas);
            continue;
        }
        for(int i = 1 ; i <= n ; i++)
            for(int j = head[i];j!=-1;j=edge[j].next)
                if(belong[i] != belong[edge[j].to])
                {
                    outdegree[belong[i]]++;
                    indegree[belong[edge[j].to]]++;
                }
        //for(int i = 1 ; i <= n ; i++)printf("belong[i] = %d\n",belong[i]);
        //for(int i = 1 ; i <= belongcnt ;i++)printf("sum[%d] = %d indegree = %d outdegree = %d\n",i,sum[i],indegree[i],outdegree[i]);
        long long ans = 0,temp = 1e8;
        for(int i = 1 ; i <= belongcnt ; i++)
        {
            if(!outdegree[i]||!indegree[i])
            {
                temp = min(temp,(long long)sum[i]);
            }
        }
        ans = (long long)n*(n-1)-(long long)temp*(n-temp)-m;
        printf("Case %d: %I64d\n",cas,ans);

    }
    return 0;

}
```



## 38.概率dp


***

```C++
for(int i = r; i>0;i--)
            for(int j = c ; j > 0 ; j--)
            {
                if(i == r && j == c)continue;
                if(fabs(1-maps[i][j][0])<1e-7)continue;
                dp[i][j] = (maps[i][j][1]*dp[i][j+1]+maps[i][j][2]*dp[i+1][j]+2)/(1-maps[i][j][0]);
            }
```



## 39.网络流


***

```C++
struct Edge
{
    int from,to,cap,flow,next;
}edge[MAXM];
int dist[MAXN],vis[MAXN],head[MAXN],cur[MAXN],top;
int n,f,d;
void init()
{
    top = 0;
    memset(head,-1,sizeof(head));
}
void addedge(int u,int v, int w)
{
    Edge E1={u,v,w,0,head[u]};
    edge[top] = E1;
    head[u] = top++;
    Edge E2 = {v,u,0,0,head[v]};
    edge[top] = E2;
    head[v] = top++;
}
void getmap()
{
    int i,j;
    int fnum,dnum;
    for(i = 1 ; i <= n ; i++)
    {
        scanf("%d%d",&fnum,&dnum);
        while(fnum--)
        {
            scanf("%d",&j);
            addedge(2*n+j,i,1);
        }
        while(dnum--)
        {
            scanf("%d",&j);
            addedge(n+i,2*n+f+j,1);
        }
        addedge(i,n+i,1);
    }
    for(i = 1 ; i <= f;i++)
        addedge(0,2*n+i,1);
    for(i = 1 ; i <= d; i++)
        addedge(2*n+f+i,2*n+f+d+1,1);
}
bool BFS(int start,int ends)
{
    queue<int> Q;
    memset(dist,-1,sizeof(dist));
    memset(vis,0,sizeof(vis));
    while(!Q.empty())Q.pop();
    Q.push(start);
    dist[start] = 0;
    vis[start] = 1;
    while(!Q.empty())
    {
        int u = Q.front();
        Q.pop();
        for(int i = head[u];i!=-1;i=edge[i].next)
        {
            Edge E = edge[i];
            if(!vis[E.to]&&E.cap>E.flow)
            {
                vis[E.to] = 1;
                dist[E.to] = dist[u] + 1;
                if(E.to == ends) return true;
                Q.push(E.to);
            }
        }
    }
    return false;
}
int DFS(int x, int a, int end)
{
    if(x==end || a==0)return a;
    int flow = 0,f;
    for(int & i = cur[x];i!=-1;i=edge[i].next)
    {
        Edge& E = edge[i];
        if(dist[E.to] == dist[x]+1 && (f=DFS(E.to,min(a,E.cap-E.flow),end)))
        {
            E.flow +=f;
            edge[i^1].flow-=f;
            flow+=f;
            a-=f;
            if(a == 0)break;
        }
    }
    return flow;
}
int Maxflow(int start,int end)
{
    int flow = 0;
    while(BFS(start,end))
    {
        memcpy(cur,head,sizeof(head));
        flow += DFS(start,INF,end);
    }
    return flow;
}
```



## 40.最小费用最大流MCMF

***

```C++
using namespace std;
struct Edge
{
    int from,to,cap,flow,cost,next;
};
Edge edge[MAXM];
int head[MAXN],edgenum,dist[MAXN],pre[MAXN],N,M,source,sink;
bool vis[MAXN];
void init()
{
    edgenum = 0;
    memset(head,-1,sizeof(head));
}
void addEdge(int u,int v,int w,int c)
{
    Edge E1 = {u,v,w,0,c,head[u]};
    edge[edgenum] = E1; head[u] = edgenum++;
    Edge E2 = {v,u,0,0,-c,head[v]};
    edge[edgenum] = E2; head[v] = edgenum++;
}
void getMap()
{
    int a,b,c;
    source = 0;sink = N+1;
    while(M--)
    {
        scanf("%d%d%d",&a,&b,&c);
        addEdge(a,b,1,c);
        addEdge(b,a,1,c);
    }
    addEdge(source,1,2,0);
    addEdge(N,sink,2,0);
}
bool SPFA(int s,int t)
{
    queue<int>Q;
    memset(dist,INF,sizeof(dist));
    memset(vis,false,sizeof(vis));
    memset(pre,-1,sizeof(pre));
    dist[s] = 0;
    vis[s] = true;
    Q.push(s);
    while(!Q.empty())
    {
        int u = Q.front();
        Q.pop();
        vis[u] = false;
        for(int i = head[u] ; i!= -1 ; i = edge[i].next)
        {
            Edge E = edge[i];
            if(dist[E.to] > dist[u] + E.cost && E.cap > E.flow)
            {
                dist[E.to] = dist[u] + E.cost;
                pre[E.to] = i;
                if(!vis[E.to])
                {
                    vis[E.to] = true;
                    Q.push(E.to);
                }
            }
        }
    }
    return pre[t] != -1;
}
void MCMF(int s,int t,int &cost)
{
    cost = 0;
    while(SPFA(s,t))
    {
        int Min = INF;
        for(int i = pre[t] ; i!= -1 ; i = pre[edge[i^1].to])
        {
            Edge E = edge[i];
            Min = min(Min,E.cap-E.flow);
        }
        for(int i = pre[t] ; i!= -1 ; i = pre[edge[i^1].to])
        {
            edge[i].flow+=Min;
            edge[i^1].flow-=Min;
            cost+=edge[i].cost*Min;
        }
    }
}
int main()
{
    while(~scanf("%d%d",&N,&M))
    {
        init();
        getMap();
        int cost;
        MCMF(source,sink,cost);
        printf("%d\n",cost);
    }
    return 0;
}
```



## 41.KM算法（KM算法用来求二分图最大权完美匹配）



```C++
#include <iostream>
#include <cstring>
#include <cstdio>

using namespace std;
const int MAXN = 305;
const int INF = 0x3f3f3f3f;

int love[MAXN][MAXN];   // 记录每个妹子和每个男生的好感度
int ex_girl[MAXN];      // 每个妹子的期望值
int ex_boy[MAXN];       // 每个男生的期望值
bool vis_girl[MAXN];    // 记录每一轮匹配匹配过的女生
bool vis_boy[MAXN];     // 记录每一轮匹配匹配过的男生
int match[MAXN];        // 记录每个男生匹配到的妹子 如果没有则为-1
int slack[MAXN];        // 记录每个汉子如果能被妹子倾心最少还需要多少期望值

int N;


bool dfs(int girl)
{
    vis_girl[girl] = true;

    for (int boy = 0; boy < N; ++boy) {
     
        if (vis_boy[boy]) continue; // 每一轮匹配 每个男生只尝试一次
     
        int gap = ex_girl[girl] + ex_boy[boy] - love[girl][boy];
     
        if (gap == 0) {  // 如果符合要求
            vis_boy[boy] = true;
            if (match[boy] == -1 || dfs( match[boy] )) {    // 找到一个没有匹配的男生 或者该男生的妹子可以找到其他人
                match[boy] = girl;
                return true;
            }
        } else {
            slack[boy] = min(slack[boy], gap);  // slack 可以理解为该男生要得到女生的倾心 还需多少期望值 取最小值 备胎的样子【捂脸
        }
    }
     
    return false;

}

int KM()
{
    memset(match, -1, sizeof match);    // 初始每个男生都没有匹配的女生
    memset(ex_boy, 0, sizeof ex_boy);   // 初始每个男生的期望值为0

    // 每个女生的初始期望值是与她相连的男生最大的好感度
    for (int i = 0; i < N; ++i) {
        ex_girl[i] = love[i][0];
        for (int j = 1; j < N; ++j) {
            ex_girl[i] = max(ex_girl[i], love[i][j]);
        }
    }
     
    // 尝试为每一个女生解决归宿问题
    for (int i = 0; i < N; ++i) {
     
        fill(slack, slack + N, INF);    // 因为要取最小值 初始化为无穷大
     
        while (1) {
            // 为每个女生解决归宿问题的方法是 ：如果找不到就降低期望值，直到找到为止
     
            // 记录每轮匹配中男生女生是否被尝试匹配过
            memset(vis_girl, false, sizeof vis_girl);
            memset(vis_boy, false, sizeof vis_boy);
     
            if (dfs(i)) break;  // 找到归宿 退出
     
            // 如果不能找到 就降低期望值
            // 最小可降低的期望值
            int d = INF;
            for (int j = 0; j < N; ++j)
                if (!vis_boy[j]) d = min(d, slack[j]);
     
            for (int j = 0; j < N; ++j) {
                // 所有访问过的女生降低期望值
                if (vis_girl[j]) ex_girl[j] -= d;
     
                // 所有访问过的男生增加期望值
                if (vis_boy[j]) ex_boy[j] += d;
                // 没有访问过的boy 因为girl们的期望值降低，距离得到女生倾心又进了一步！
                else slack[j] -= d;
            }
        }
    }
     
    // 匹配完成 求出所有配对的好感度的和
    int res = 0;
    for (int i = 0; i < N; ++i)
        res += love[ match[i] ][i];
     
    return res;

}

int main()
{
    while (~scanf("%d", &N)) {

        for (int i = 0; i < N; ++i)
            for (int j = 0; j < N; ++j)
                scanf("%d", &love[i][j]);
     
        printf("%d\n", KM());
    }
    return 0;

}   
```



## 42.匈牙利算法


***

```C++
const int MAXN = 500;
int yN,vN;
int g[MAXN][MAXN];
int linker[MAXN];
bool vis[MAXN];
int k,m,n,u,v;
bool dfs(int u)
{
    int v;
    for(v = 1 ; v <= n ; v++)
    {
        if(g[u][v] && ! vis[v])
        {
            vis[v] = true;
            if(linker[v] == -1 || dfs(linker[v]))
            {
                linker[v] = u;
                return true;
            }
        }

    }
    return false;

}
int hungary()
{
    int res = 0;
    int u;
    memset(linker,-1,sizeof(linker));
    for(u = 1 ;u <= n ;u++)
    {
        memset(vis,0,sizeof(vis));
        if(dfs(u))res++;
    }
    return res;
}
```



## 43.计算几何

**以下多个模板均是计算几何相关内容，因内容较少且模板较大所以不统一标号需要自查**

```C++
/***************************************************************/
/***************************************************************/
/*定义一个点*/
/***************************************************************/
struct Point{  
    double x,y;  
    Point(double _x=0,double _y=0){  
        x=_x;y=_y;  
    }  
};  
Point operator + (const Point &a,const Point &b){  
    return Point(a.x+b.x,a.y+b.y);  
}  
Point operator - (const Point &a,const Point &b){  
    return Point(a.x-b.x,a.y-b.y);  
}  
Point operator * (const Point &a,const double &p){  
    return Point(a.x*p,a.y*p);  
}  
Point operator / (const Point &a,const double &p){  
    return Point(a.x/p,a.y/p);  
}  
bool operator < (const Point &a,const Point &b){  
    return a.x<b.x||(a.x==b.x&&a.y<b.y);  
}  
bool operator == (const Point &a,const Point &b){  
    return dcmp(a.x-b.x)==0&&dcmp(a.y-b.y)==0;  
}  
double Dot(Point  a,Point b){  
    return a.x*b.x+a.y*b.y;  
}  
double Length(Point a){  
    return sqrt(Dot(a,a));  
}  
double Angle(Point a,Point b){  
    return acos(Dot(a,b)/Length(a)/Length(b));  
}  
double angle(Point a){  
    return atan2(a.y,a.x);  
}  
double Cross(Point a,Point b){  
    return a.x*b.y-a.y*b.x;  
}  
Point vecunit(Point a){  
    return a/Length(a);  
}  
Point Normal(Point a){  
    return Point(-a.y,a.x)/Length(a);  
}  
Point Rotate(Point a,double rad){  
    return Point(a.x*cos(rad)-a.y*sin(rad),a.x*sin(rad)+a.y*cos(rad));  
}  
double Area2(Point a,Point b,Point c){  
    return Length(Cross(b-a,c-a));  
}  
struct Line{  
    Point p,v;  
    double ang;  
    Line(){};  
    Line(Point p,Point v):p(p),v(v){  
        ang=atan2(v.y,v.x);  
    }  
    bool operator < (const Line &L) const {  
        return ang<L.ang;  
    }  
};  
bool OnLeft(const Line &L,const Point &p){  
    return dcmp(Cross(L.v,p-L.p))>=0;  
}  
Point GetLineIntersection(Point p,Point v,Point q,Point w){  
    Point u=p-q;  
    double t=Cross(w,u)/Cross(v,w);  
    return p+v*t;  
}  
Point GetLineIntersection(Line a,Line b){  
    return GetLineIntersection(a.p,a.v,b.p,b.v);  
}  

/***************************************************************/
/*求点的最小距离*/
/***************************************************************/
const int SIZE = 100005;
const int L = -1;
const int R = 1;
typedef struct
{
	int index;
	double x;
	double y;   /*用于记录坐标点*/
}coord;
coord num[SIZE], c[SIZE]/*用作辅助数组*/;
double getDistance(coord &bi1, coord &bi2)  /*求得两点之间的距离*/
{
	return sqrt(pow(bi1.x - bi2.x, 2.0) + pow(bi1.y - bi2.y, 2.0));
}
bool cmpx(coord &bi1, coord &bi2)
{
	if (bi1.x == bi1.x)
		return bi1.y < bi2.y;
	else
	return bi1.x < bi2.x;
}
bool cmpy(coord &bi1, coord &bi2)
{
	if (bi1.y == bi2.y)
		return bi1.x < bi2.x;
	else
		return bi1.y < bi2.y;
}
inline double min(double &bi1, double &bi2, double &bi3)
{
	double minLength;
	minLength = bi1 > bi2 ? bi2 : bi1;
	minLength = minLength > bi3 ? bi3 : minLength;
	return minLength;
}
inline double minDist(double &bi1, double &bi2)
{
	if (bi1 > bi2)
		return bi2;
	return bi1;
}
double divide_conquer(int low, int high) /*分治法求最小距离*/
{
	double dis;
	int count = high - low;
	if (count == 0)
		return 0;
	else if (count == 1)  /*两个数*/
		dis = getDistance(num[low], num[high]);
	else if (count == 2)  /*三个数*/
	{
		double temp1, temp2, temp3;
		temp1 = getDistance(num[low], num[low + 1]);
		temp2 = getDistance(num[low + 1], num[high]);
		temp3 = getDistance(num[low], num[high]);
		dis = min(temp1, temp2, temp3);
	}
	else   /*大于三个数的情况*/
	{
		double leftmin, rightmin, min;
		int mid = (low + high) / 2;
		int p = 0;
		int i, j;
		leftmin = divide_conquer(low, mid);  /*求得左边部分的最小值*/
		rightmin = divide_conquer(mid + 1, high);  /*求得右边部分的最小值*/
		dis = minDist(leftmin, rightmin);
		/*下面从所有坐标点中找出所有x在leftCoord到rightCoord之间的点*/
		for (i = low; i <= mid; i++)
		{
			double leftCoord = num[mid].x - dis;
			if (num[i].x >= leftCoord)
			{
				c[p].index = L;  /*标识属于左边部分*/
				c[p].x = num[i].x;
				c[p].y = num[i].y;
				p++;
			}
		}
		for ( ; i <= high; i++)
		{
			double rightCoord = num[mid].x + dis;
			if (num[i].x <= rightCoord)
			{
				c[p].index = R;  /*标识属于右边部分*/
				c[p].x = num[i].x;
				c[p].y = num[i].y;
				p++;
			}
		}
		sort(c, c + p, cmpy);   /*找到的点再从小到大按照y排序一次*/
		for (i = 0; i < p; i++)
		{
			for (j = 1; (j <= 7) && (i + j < p); j++)
			{
				if (c[i].index != c[i + j].index) /*最小值只可能出现在两个分别属于不同的边的点上*/
				{
					min = getDistance(c[i], c[i + j]);
					if(min < dis)
					dis = min;
				}
			}
		}
	}
	return dis;
}


int main ()
{
	int n;
	while (scanf("%d",&n),n)
	{
		double result = 0;
		for (int i = 0; i < n; i++)
		{
			num[i].index = 0;
			scanf("%lf%lf",&num[i].x,&num[i].y);
		}
		sort (num, num + n, cmpx);
		result = divide_conquer(0, n - 1);
		printf("%.2lf\n", result / 2);
	}
	return 0;
}
/***************************************************************/
/*求凸包的最小覆盖圆*/
/***************************************************************/
#define eps 1e-8
int n,top,m,cnt;
double x,y;
const int N=1008;
struct point
{
    double x,y;
    point(){}
    point(double a,double b):x(a),y(b){}
    point operator-(point a){
        return point(x-a.x,y-a.y);
    }
    point operator+(point a){
        return point(x+a.x,y+a.y);
    }
    double operator*(point a){
        return x*a.y-y*a.x;
    }
    bool operator<(const point a) const{
        if(fabs(x-a.x)<eps) return y<a.y;
        return x<a.x;
    }
    double len(){
        return sqrt(x*x+y*y);
    }
}a[N],p[N];
double cj(point a,point b,point c) {return (a-c)*(b-c);}
void graham()
{
    sort(a+1,a+cnt+1);
    p[1]=a[1],p[2]=a[2],top=2;
    for(int i=3;i<=cnt;i++)
    {
        while(top>1&&cj(a[i],p[top],p[top-1])>=0) top--;
        p[++top]=a[i];
    }
    m=top;
    p[++top]=a[cnt-1];
    for(int i=cnt-2;i>=1;i--)
    {
        while(top>m&&cj(a[i],p[top],p[top-1])>=0) top--;
        p[++top]=a[i];
    }
}
int main()
{
    scanf("%d",&n);
    for(int i = 1 ; i <= n ; i++)
    {
        scanf("%lf%lf",&a[i].x,&a[i].y);
    }
    sort(a+1,a+n+1);
    cnt=1;
    for(int i = 2 ; i <= n ;i++)
    {
        if(fabs(a[i].x-a[cnt].x)>eps||fabs(a[i].y-a[cnt].y)>eps) a[++cnt]=a[i];
    }
    graham();
    double ans=0.0;
    int s;
    for(int i = 2 ; i <= top-1 ; i++)
    ans+=cj(p[i],p[i+1],p[1]);
    ans/=100.0;
    s=(int)ans;
    printf("%d",s);
    return 0;
}
/***************************************************************/
/*旋转卡壳求凸包面积*/
/***************************************************************/
struct Point
{
    int x,y;
    Point(int _x=0,int _y=0)
    {
        x=_x;
        y=_y;
    }
    Point operator - (const Point &b)const
    {
        return Point(x-b.x,y-b.y);
    }
    int operator ^(const Point &b)const
    {
        return x*b.y-y*b.x;
    }
    int operator *(const Point &b)const
    {
        return x*b.x+y*b.y;
    }
};
int dist2(Point a, Point b)
{
    return (a-b)*(a-b);
}
const int MAXN = 50010;
Point list[MAXN];
int Stack[MAXN],top;
bool _cmp(Point p1,Point p2)
{
    int tmp = (p1-list[0])^(p2-list[0]);
    if(tmp > 0)return true;
    else if(tmp == 0 && dist2(p1,list[0]) <= dist2(p2,list[0]))
        return true;
    else return false;
}
void Graham(int n)
{
    Point p0;
    int k=0;
    p0 = list[0];
    for(int i = 1; i < n ;i++)
    {
        if(p0.y>list[i].y||(p0.y==list[i].y&&p0.x>list[i].x))
        {
            p0=list[i];
            k=i;
        }
    }
    swap(list[0],list[k]);
    sort(list+1,list+n,_cmp);
    if(n==1)
    {
        top=1;
        Stack[0]=0;
        return;
    }
    if(n==2)
    {
        top=2;
        Stack[0] = 0;
        Stack[1] = 1;
        return;
    }
    Stack[0] = 0;
    Stack[1] = 1;
    top=2;
    for(int i = 2 ; i < n ; i++)
    {
        while(top>1&&((list[Stack[top-1]]-list[Stack[top-2]])^(list[i]-list[Stack[top-2]]))<=0)
            top--;
        Stack[top++]=i;
    }
}
int rotating_calipers(Point p[],int n)
{
    int ans = 0;
    Point v;
    int cur = 1;
    for(int i = 0 ; i < n ; i++)
    {
        v = p[i]-p[(i+1)%n];
        while((v^(p[(cur+1)%n]-p[cur])) < 0)
            cur = (cur+1)%n;
        ans = max(ans,max(dist2(p[i],p[cur]),dist2(p[(i+1)%n],p[(cur+1)%n])));
    }
    return ans;
}
Point p[MAXN];
int main()
{
    int n;
    while(~scanf("%d",&n))
    {
        for(int i = 0 ; i < n ; i++)
            scanf("%d%d",&list[i].x,&list[i].y);
        Graham(n);
        for(int i = 0 ; i < top ; i++)
            p[i] = list[Stack[i]];
        printf("%d\n",rotating_calipers(p,top));
    }
    return 0;
}
/***************************************************************/
/*求凸包面积（整数模板）*/
/***************************************************************/
#include<bits/stdc++.h>
using namespace std;
const int MAX=1e5+10;
typedef long long ll;
struct Point{int x,y;}p[MAX];
Point operator+(Point A,Point B){return (Point){A.x+B.x,A.y+B.y};}        //vector A+B
Point operator-(Point A,Point B){return (Point){A.x-B.x,A.y-B.y};}        //vector A-B
ll operator^(Point A,Point B){return 1ll*A.x*B.y-1ll*A.y*B.x;}            //corss(A,B)
ll Polyarea(Point *p,int n)
{
    ll area=0;
    for(int i=1;i<n-1;i++)area+=(p[i]-p[0])^(p[i+1]-p[0]);
    return abs(area);
}

int main()
{
    int n;
    cin>>n;
    for(int i=0;i<n;i++)scanf("%d%d",&p[i].x,&p[i].y);
    ll S=Polyarea(p,n);
    printf("%d",S);
}

/***************************************************************/
/*求凸包面积（这个写法比较舒服可以用作模板）*/
/***************************************************************/
#define eps 1e-8
int n,top,m,cnt;
double x,y;
const int N=1008;
struct point
{
    double x,y;
    point(){}
    point(double a,double b):x(a),y(b){}
    point operator-(point a){
        return point(x-a.x,y-a.y);
    }
    point operator+(point a){
        return point(x+a.x,y+a.y);
    }
    double operator*(point a){
        return x*a.y-y*a.x;
    }
    bool operator<(const point a) const{
        if(fabs(x-a.x)<eps) return y<a.y;
        return x<a.x;
    }
    double len(){
        return sqrt(x*x+y*y);
    }
}a[N],p[N];
double cj(point a,point b,point c) {return (a-c)*(b-c);}
void graham()
{
    sort(a+1,a+cnt+1);
    p[1]=a[1],p[2]=a[2],top=2;
    for(int i=3;i<=cnt;i++)
    {
        while(top>1&&cj(a[i],p[top],p[top-1])>=0) top--;
        p[++top]=a[i];
    }
    m=top;
    p[++top]=a[cnt-1];
    for(int i=cnt-2;i>=1;i--)
    {
        while(top>m&&cj(a[i],p[top],p[top-1])>=0) top--;
        p[++top]=a[i];
    }
}
int main()
{
    scanf("%d",&n);
    for(int i = 1 ; i <= n ; i++)
    {
        scanf("%lf%lf",&a[i].x,&a[i].y);
    }
    sort(a+1,a+n+1);
    cnt=1;
    for(int i = 2 ; i <= n ;i++)
    {
        if(fabs(a[i].x-a[cnt].x)>eps||fabs(a[i].y-a[cnt].y)>eps) a[++cnt]=a[i];
    }
    graham();
    double ans=0.0;
    int s;
    for(int i = 2 ; i <= top-1 ; i++)
    ans+=cj(p[i],p[i+1],p[1]);
    ans/=100.0;
    s=(int)ans;
    printf("%d",s);
    return 0;
}
/***************************************************************/
/*多边形和圆面积并*/
/***************************************************************/
const double pi=acos(-1.0);
const double e=exp(1.0);
const double eps=1e-8;
const int maxn=100005;
double R,k;
int n,m;
struct point          // 点或向量结构
{
    double x,y;
    point(double _x=0.0,double _y=0.0):x(_x),y(_y) {}
    point operator - (const point &p)
    {
        return point(x-p.x,y-p.y);
    }
    double sqrx()    //向量的模
    {
        return sqrt(x*x+y*y);
    }
} area[maxn];

int dcmp(double x)
{
    return (x>eps)-(x<-eps);
}

double xmult(point &p1,point &p2,point &p0)//叉积
{
    return (p1.x-p0.x)*(p2.y-p0.y)-(p1.y-p0.y)*(p2.x-p0.x);
}

double distancex(point &p1,point &p2)
{
    return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));
}

point intersection(point u1,point u2,point v1,point v2)   //两直线交点
{
    point ret = u1;
    double t = ((u1.x-v1.x)*(v1.y-v2.y)-(u1.y-v1.y)*(v1.x-v2.x))/((u1.x-u2.x)*(v1.y-v2.y)-(u1.y-u2.y)*(v1.x-v2.x));
    ret.x += (u2.x-u1.x)*t;
    ret.y += (u2.y-u1.y)*t;
    return ret;
}

void intersection_line_circle(point c, double r, point l1, point l2, point & p1, point & p2) //直线与圆相交
{
    point p = c;
    double t;
    p.x += l1.y-l2.y;
    p.y += l2.x-l1.x;
    p = intersection(p, c, l1, l2);
    t = sqrt(r*r-distancex(p, c)*distancex(p, c))/distancex(l1, l2);
    p1.x = p.x+(l2.x-l1.x)*t;
    p1.y = p.y+(l2.y-l1.y)*t;
    p2.x = p.x-(l2.x-l1.x)*t;
    p2.y = p.y-(l2.y-l1.y)*t;
}

point len_pot_seg(point p, point l1, point l2)//点到线段的最近距离
{
    point t = p;
    t.x += l1.y-l2.y;
    t.y += l2.x-l1.x;
    if (xmult(l1, t, p)*xmult(l2, t, p)>eps)
        return distancex(p, l1)<distancex(p, l2) ? l1 : l2;
    return intersection(p, t, l1, l2);
}

double distp(point & a, point & b)
{
    return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);
}

double Direct_Triangle_Circle_Area(point a, point b, point o, double r)
{
    double sign = 1.0;
    a = a-o;
    b = b-o;
    o = point(0.0, 0.0);
    if(fabs(xmult(a, b, o)) < eps) return 0.0;
    if(distp(a, o) > distp(b, o))
    {
        swap(a, b);
        sign = -1.0;
    }
    if (distp(a, o) < r*r+eps)
    {
        if (distp(b, o) < r*r+eps) return xmult(a, b, o)/2.0*sign;
        point p1, p2;
        intersection_line_circle(o, r, a, b, p1, p2);
        if (distancex(p1, b) > distancex(p2, b)) swap(p1, p2);
        double ret1 = fabs(xmult(a, p1, o));
        double ret2 = acos((p1.x*b.x+p1.y*b.y)/p1.sqrx()/b.sqrx())*r*r;
        double ret = (ret1+ret2)/2.0;
        if ((xmult(a, b, o)<eps && sign>0.0) || (xmult(a, b, o)>eps && sign<0.0)) ret = -ret;
        return ret;
    }
    point ins = len_pot_seg(o, a, b);
    if(distp(o, ins)>r*r-eps)
    {
        double ret = acos((a.x*b.x+a.y*b.y)/a.sqrx()/b.sqrx())*r*r/2.0;
        if((xmult(a, b, o)<eps && sign>0.0) || (xmult(a, b, o)>eps && sign<0.0)) ret = -ret;
        return ret;
    }
    point p1, p2;
    intersection_line_circle(o, r, a, b, p1, p2);
    double cm = r/(distancex(o, a)-r);
    point m = point((o.x+cm*a.x)/(1+cm),(o.y+cm*a.y)/(1+cm));
    double cn = r/(distancex(o, b)-r);
    point n = point((o.x+cn*b.x)/(1+cn),(o.y+cn*b.y)/(1+cn));
    double ret1 = acos((m.x*n.x+m.y*n.y)/m.sqrx()/n.sqrx())*r*r;
    double ret2 = acos((p1.x*p2.x+p1.y*p2.y)/p1.sqrx()/p2.sqrx())*r*r-fabs(xmult(p1, p2, o));
    double ret = (ret1-ret2)/2.0;
    if((xmult(a, b, o)<eps && sign>0.0)||(xmult(a, b, o)>eps && sign<0.0)) ret=-ret;
    return ret;
}

int main()
{
    double x,y,H;
    double x1,y1,R;
    while(~scanf("%lf%lf%lf",&x,&y,&H))
    {
        scanf("%lf%lf%lf%d",&x1,&y1,&R,&n);
        for(int i=0; i<n; i++) scanf("%lf%lf", &area[i].x, &area[i].y);
        double V=sqrt(2*10*H);
        double t=V/10;
        double ceter_x0=x+x1*t;
        double ceter_y0=y+y1*t;
        point ceter_xy=point(ceter_x0,ceter_y0);
        double sum=0.0;
        for(int i=0; i<n-1; i++) sum += Direct_Triangle_Circle_Area(area[i], area[i+1], ceter_xy, R);
        sum += Direct_Triangle_Circle_Area(area[n-1], area[0], ceter_xy, R);
        printf("%.2f\n",fabs(sum));
    } return 0;
}
/***************************************************************/
/*单位圆能覆盖最多点*/
/***************************************************************/
#define eps 1e-8
using namespace std;
struct point{
	double x,y;
}A[310];
double dist(point a,point b){
	return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
}
void getmid(point p1,point p2,point &center){//计算圆心坐标画图即可看出
	point mid;
	mid.x=(p1.x+p2.x)/2.0;mid.y=(p1.y+p2.y)/2.0;
	double angle=atan2(p1.x-p2.x,p2.y-p1.y);
	double dcm=sqrt(1-dist(p1,mid)*dist(p1,mid));
	center.x=mid.x+dcm*cos(angle);center.y=mid.y+dcm*sin(angle);
}
int main()
{
	int n,i,j,k;
	while(scanf("%d",&n),n){
		for(i=0;i<n;++i){
			scanf("%lf%lf",&A[i].x,&A[i].y);
		}
		int ans=1;
		for(i=0;i<n;++i){
			for(j=i+1;j<n;++j){
				if(dist(A[i],A[j])>2.0)continue;
				point center;
				getmid(A[i],A[j],center);
				int cnt=0;
				for(k=0;k<n;++k){
					if(dist(A[k],center)<1.0+eps)cnt++;
				}
				ans=max(ans,cnt); 
			}
		}
		printf("%d\n",ans);
	}
	return 0;
}
```

## 44.FFT（求卷积）

```C++

typedef long long ll;
using namespace std;
const int N = 500005;
const double pi = acos(-1.0);

char s1[N],s2[N];
int len,res[N];

struct Complex
{
    double r,i;
    Complex(double r=0,double i=0):r(r),i(i) {};
    Complex operator+(const Complex &rhs)
    {
        return Complex(r + rhs.r,i + rhs.i);
    }
    Complex operator-(const Complex &rhs)
    {
        return Complex(r - rhs.r,i - rhs.i);
    }
    Complex operator*(const Complex &rhs)
    {
        return Complex(r*rhs.r - i*rhs.i,i*rhs.r + r*rhs.i);
    }
} va[N],vb[N];

//雷德算法--倒位序
void rader(Complex F[],int len) //len = 2^M,reverse F[i] with  F[j] j为i二进制反转
{
    int j = len >> 1;
    for(int i = 1;i < len - 1;++i)
    {
        if(i < j) swap(F[i],F[j]);  // reverse
        int k = len>>1;
        while(j>=k)
        {
            j -= k;
            k >>= 1;
        }
        if(j < k) j += k;
    }
}
//FFT实现
void FFT(Complex F[],int len,int t)
{
    rader(F,len);
    for(int h=2;h<=len;h<<=1) //分治后计算长度为h的DFT
    {
        Complex wn(cos(-t*2*pi/h),sin(-t*2*pi/h)); //单位复根e^(2*PI/m)用欧拉公式展开
        for(int j=0;j<len;j+=h)
        {
            Complex E(1,0); //旋转因子
            for(int k=j;k<j+h/2;++k)
            {
                Complex u = F[k];
                Complex v = E*F[k+h/2];
                F[k] = u+v; //蝴蝶合并操作
                F[k+h/2] = u-v;
                E=E*wn; //更新旋转因子
            }
        }
    }
    if(t==-1)   //IDFT
        for(int i=0;i<len;++i)
            F[i].r/=len;
}
//求卷积(这是自身求卷积)
void Conv(Complex a[],int len)
{
    FFT(a,len,1);
    for(int i=0;i<len;++i) a[i] = a[i]*a[i];
    FFT(a,len,-1);
}
//求卷积(这是求两个不同的卷积)
void Conv1(Complex a[],Complex b[],int len)
{
    FFT(a,len,1);
    FFT(b,len,1);
    for(int i=0;i<len;++i) a[i] = a[i]*b[i];
    FFT(a,len,-1);
}
int a[N];
Complex F[N];
ll num[N],sum[N];
int n;

void init()//如果是两个不同的数组求卷积则len取其中大的
{
    memset(num,0,sizeof(num));
    scanf("%d",&n);
    for(int i=0; i<n; i++)
    {
        scanf("%d",&a[i]);
        num[a[i]]++;
    }
    sort(a, a + n);
    int len1 = a[n-1] + 1;
    len  = 1;
    while(len < len1*2) len <<= 1;
    for(int i=0; i<len1; i++)
        F[i] = Complex(num[i],0);
    for(int i=len1; i<len; i++)
        F[i] = Complex(0,0);
}
int main()
{
    int t;
    scanf("%d",&t);
    while(t--)
    {
    	init();
        Conv(F,len);
        //num数组就是卷积后的结果，表示两两组合
        for(int i=0; i<len; i++)
            num[i] = (ll)(F[i].r+0.5);

	}
	return 0;

}
```



## 45.NTT（求大素数卷积）


***

```C++
const ll M = 998244353;
const ll g = 3;
ll Pow(ll a,ll n)
{
    ll ret = 1;
    while(n)
    {
        if(n&1)ret= ret * a%M;
        n >>= 1;
        a = a * a %M;
    }
    return ret;
}
void rader(ll y[],int len)
{
    for(int i  = 1 , j = len / 2; i < len -1;i++)
    {
        if(i<j)swap(y[i],y[j]);
        int k = len/2;
        while(j >= k)
        {
            j-=k;
            k/=2;
        }
        if(j < k)j+=k;
    }
}
void ntt(ll y[],int len,int on)
{
    rader(y,len);
    for(int h = 2 ; h <= len ; h <<= 1)
    {
        ll wn = Pow(g,(M-1)/h);
        if(on == -1)wn = Pow(wn,M-2);
        for(int j = 0 ; j < len ; j += h)
        {
            ll w = 1;
            for(int k = j ; k < j +h/2;k++)
            {
                ll u = y[k];
                ll t = w * y[k+h/2]%M;
                y[k] = (u+t)%M;
                y[k+h/2] = (u-t+M)%M;
                w =  w * wn % M;
            }
        }
    }
    if(on == -1)
    {
        ll t = Pow(len,M-2);
        for(int i = 0 ; i < len ; i++)
            y[i] = y[i] * t %M;
    }
}
```



## 46.FWT(求异或卷积)


***

```C++
void FWT(long long a[],int l,int on)
{
    for(int d = 1 ; d < l ; d <<= 1)
    {
        for(int m =d << 1,i=0;i<l;i+=m)
        {
            for(int j = 0 ; j < d ; j++)
            {
                ll x = a[i+j],y=a[i+j+d];
                a[i+j]=x+y;
                a[i+j+d]=x-y;
                if(on < 0)
                {
                    a[i+j]>>=1;
                    a[i+j+d]>>=1;
                }
            }
        }
    }
}
void Conv(ll a[],ll b[],int len)
{
    FWT(a,len,1);
    FWT(b,len,1);
    for(int i = 0 ; i < len ; i++)
    {
        a[i] = b[i]*a[i];
    }
    FWT(a,len,-1);
}
```



## 47.后缀数组模板倍增法（后附一个后缀数组理解程序）



```C++
const int maxn=1000010;
int wa[maxn],wb[maxn],wv[maxn],wsf[maxn];
int cmp(int *r,int a,int b,int l)
{
    return r[a]==r[b]&&r[a+l]==r[b+l];
}
//sa k表示第k小的后缀坐标
//Rank k表示坐标为k的排名
// height k 表示示串 s 的字典序排名为 k 的后缀与字典序排名为 k ? 1的后缀之间的LCP
void get_sa(int *r,int *sa,int n,int m)
{
    int i,j,p,*x=wa,*y=wb,*t;
    for(i=0;i<m;i++) wsf[i]=0;
    for(i=0;i<n;i++) wsf[x[i]=r[i]]++;
    for(i=1;i<m;i++) wsf[i]+=wsf[i-1];
    for(i=n-1;i>=0;i--) sa[--wsf[x[i]]]=i;
    for(j=1,p=1;p<n;j*=2,m=p)
    {
        for(p=0,i=n-j;i<n;i++) y[p++]=i;
        for(i=0;i<n;i++) if(sa[i]>=j) y[p++]=sa[i]-j;
        for(i=0;i<n;i++) wv[i]=x[y[i]];
        for(i=0;i<m;i++) wsf[i]=0;
        for(i=0;i<n;i++) wsf[wv[i]]++;
        for(i=1;i<m;i++) wsf[i]+=wsf[i-1];
        for(i=n-1;i>=0;i--) sa[--wsf[wv[i]]]=y[i];
        for(t=x,x=y,y=t,p=1,x[sa[0]]=0,i=1;i<n;i++)
        x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;
    }
    return;
}
int Rank[maxn],height[maxn];
void get_height(int *r,int *sa,int n)
{
    int i,j,k=0;
    for(i=1;i<=n;i++) Rank[sa[i]]=i;
    for(i=0;i<n;height[Rank[i++]]=k)
    for(k?k--:0,j=sa[Rank[i]-1];r[i+k]==r[j+k];k++);
    return;
}
int dmin[maxn][20];
void initMin(int n)
{
    for(int i=1;i<=n;i++) dmin[i][0]=height[i];
    for(int j=1;(1<<j)<=n;j++)
        for(int i=1;i+(1<<j)-1<=n;i++)
            dmin[i][j]=min(dmin[i][j-1] , dmin[i+(1<<(j-1))][j-1]);
}
int RMQ(int L,int R)//取得范围最小值
{
    int k=0;
    while((1<<(k+1))<=R-L+1)k++;
    return min(dmin[L][k] , dmin[R-(1<<k)+1][k]);
}
int LCP(int i,int j)//求后缀i和j的LCP最长公共前缀
{
    int L=Rank[i],R=Rank[j];
    if(L>R) swap(L,R);
    L++;//注意这里
    return RMQ(L,R);
}
char str[maxn];
int s[maxn],sa[maxn];
int main()
{
    int T;
    scanf("%d",&T);
    while(T--)
    {
        scanf("%s",str);
        int n=strlen(str);
        for(int i=0;i<=n;i++)s[i]=str[i];
        get_sa(s,sa,n+1,128);
        get_height(s,sa,n);
    }
    return 0;
}
/***************************************************************/
/*理解后缀数组*/
/***************************************************************/
#include <cstdio>
#include <iostream>
#include <cstring>
#define  LL long long
#define  ULL unsigned long long
using namespace std;
const int MAXN=100010;
//以下为倍增算法求后缀数组
int wa[MAXN],wb[MAXN],wv[MAXN],Ws[MAXN];
int cmp(int *r,int a,int b,int l)
{return r[a]==r[b]&&r[a+l]==r[b+l];}
/**< 传入参数：str,sa,len+1,ASCII_MAX+1 */
void da(const char r[],int sa[],int n,int m)
{
      int i,j,p,*x=wa,*y=wb,*t;
      for(i=0; i<m; i++) Ws[i]=0;
      for(i=0; i<n; i++) Ws[x[i]=r[i]]++;//以字符的ascii码为下标
      for(i=1; i<m; i++) Ws[i]+=Ws[i-1];
      for(i=n-1; i>=0; i--) sa[--Ws[x[i]]]=i;
      /*cout<<"SA"<<endl;;
      for(int i=0;i<n+1;i++)cout<<sa[i]<<' ';*/
      for(j=1,p=1; p<n; j*=2,m=p)
      {
            for(p=0,i=n-j; i<n; i++) y[p++]=i;
            for(i=0; i<n; i++) if(sa[i]>=j) y[p++]=sa[i]-j;
            for(i=0; i<n; i++) wv[i]=x[y[i]];
            for(i=0; i<m; i++) Ws[i]=0;
            for(i=0; i<n; i++) Ws[wv[i]]++;
            for(i=1; i<m; i++) Ws[i]+=Ws[i-1];
            for(i=n-1; i>=0; i--) sa[--Ws[wv[i]]]=y[i];
            for(t=x,x=y,y=t,p=1,x[sa[0]]=0,i=1; i<n; i++)
                  x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;
      }
      return;
}
int sa[MAXN],Rank[MAXN],height[MAXN];
//求height数组
/**< str,sa,len */
void calheight(const char *r,int *sa,int n)
{
      int i,j,k=0;
      for(i=1; i<=n; i++) Rank[sa[i]]=i;
      for(i=0; i<n; height[Rank[i++]]=k)
            for(k?k--:0,j=sa[Rank[i]-1]; r[i+k]==r[j+k]; k++);
      // Unified
      for(int i=n;i>=1;--i) ++sa[i],Rank[i]=Rank[i-1];
}

char str[MAXN];
int main()
{
      while(scanf("%s",str)!=EOF)
      {
            int len=strlen(str);
            da(str,sa,len+1,130);
            calheight(str,sa,len);
            puts("--------------All Suffix--------------");
            for(int i=1; i<=len; ++i)
            {
                  printf("%d:\t",i);
                  for(int j=i-1; j<len; ++j)
                        printf("%c",str[j]);
                  puts("");
            }
            puts("");
            puts("-------------After sort---------------");
            for(int i=1; i<=len; ++i)
            {
                  printf("sa[%2d ] = %2d\t",i,sa[i]);
                  for(int j=sa[i]-1; j<len; ++j)
                        printf("%c",str[j]);
                  puts("");
            }
            puts("");
            puts("---------------Height-----------------");
            for(int i=1; i<=len; ++i)
                  printf("height[%2d ]=%2d \n",i,height[i]);
            puts("");
            puts("----------------Rank------------------");
            for(int i=1; i<=len; ++i)
                  printf("Rank[%2d ] = %2d\n",i,Rank[i]);
            puts("------------------END-----------------");
      }
      return 0;
}
```



## 48.后缀数组模板DC3（如果数据量超过1e6要使用DC3）


***

```C++
//maxn要为三倍的最大长度
#include <bits/stdc++.h>
#define F(x) ((x)/3+((x)%3==1?0:tb))
#define G(x) ((x)<tb?(x)*3+1:((x)-tb)*3+2)
using namespace std;
const int MAXN = 3000000+100;
const int N = MAXN;
const int INF=1e9+7;
int wa[MAXN],wb[MAXN],wv[MAXN],Ws[MAXN];
int sa[MAXN],height[MAXN],RANK[MAXN];
int len[MAXN];
int c0(int *r,int a,int b)
{
    return r[a]==r[b]&&r[a+1]==r[b+1]&&r[a+2]==r[b+2];
}
int c12(int k,int *r,int a,int b)
{
    if(k==2) return r[a]<r[b]||(r[a]==r[b]&&c12(1,r,a+1,b+1));
    else return r[a]<r[b]||(r[a]==r[b]&&wv[a+1]<wv[b+1]);
}
void Sort(int *r,int *a,int *b,int n,int m)
{
    int i;
    for(i=0;i<n;i++) wv[i]=r[a[i]];
    for(i=0;i<m;i++) Ws[i]=0;
    for(i=0;i<n;i++) Ws[wv[i]]++;
    for(i=1;i<m;i++) Ws[i]+=Ws[i-1];
    for(i=n-1;i>=0;i--) b[--Ws[wv[i]]]=a[i];
    return;
}
void dc3(int *r,int *sa,int n,int m) //涵义与DA 相同
{
    int i,j,*san=sa+n,ta=0,tb=(n+1)/3,tbc=0,p;
    int *rn=r+n;
    r[n]=r[n+1]=0;
    for(i=0;i<n;i++) if(i%3!=0) wa[tbc++]=i;
    Sort(r+2,wa,wb,tbc,m);
    Sort(r+1,wb,wa,tbc,m);
    Sort(r,wa,wb,tbc,m);
    for(p=1,rn[F(wb[0])]=0,i=1;i<tbc;i++)
        rn[F(wb[i])]=c0(r,wb[i-1],wb[i])?p-1:p++;
    if(p<tbc) dc3(rn,san,tbc,p);
    else for(i=0;i<tbc;i++) san[rn[i]]=i;
    for(i=0;i<tbc;i++) if(san[i]<tb) wb[ta++]=san[i]*3;
    if(n%3==1) wb[ta++]=n-1;
    Sort(r,wb,wa,ta,m);
    for(i=0;i<tbc;i++) wv[wb[i]=G(san[i])]=i;
    for(i=0,j=0,p=0;i<ta && j<tbc;p++)
        sa[p]=c12(wb[j]%3,r,wa[i],wb[j])?wa[i++]:wb[j++];
    for(;i<ta;p++) sa[p]=wa[i++];
    for(;j<tbc;p++) sa[p]=wb[j++];
    return;
}
void calheight(int *r,int *sa,int n)
{   // 此处N为实际长度
    int i,j,k=0;
    // height[]的合法范围为 1-N, 其中0是结尾加入的字符
    for(i=1;i<=n;i++)
        RANK[sa[i]]=i;
    // 根据SA求RANK
    for(i=0;i<n; height[RANK[i++]] = k )
        // 定义：h[i] = height[ RANK[i] ]
        for(k?k--:0,j=sa[RANK[i]-1];
            r[i+k]==r[j+k]; k++);
    //根据 h[i] >= h[i-1]-1 来优化计算height过程
}

int dp[MAXN][20];
void Rmq_Init(int n){
    int m=floor(log(n+0.0)/log(2.0));
    for(int i=1;i<=n;i++) dp[i][0]=height[i];
    for(int i=1;i<=m;i++){
        for(int j=n;j;j--){
            dp[j][i]=dp[j][i-1];
            if(j+(1<<(i-1))<=n)
                dp[j][i]=min(dp[j][i],dp[j+(1<<(i-1))][i-1]);
        }
    }
}
int Rmq_Query(int l,int r){
    int a=RANK[l],b=RANK[r];
    if(a>b) swap(a,b);
    a++;
    int m=floor(log(b-a+1.0)/log(2.0));
    return min(dp[a][m],dp[b-(1<<m)+1][m]);
}
char str[3000100];
int s[3000100],n = 0;

int main()
{
    scanf("%s",str);
    n = strlen(str);
    for(int i = 0 ; i <= n ; i++)
        s[i]=str[i];
    dc3(s,sa,n+1,128);
    calheight(s,sa,n);
    return 0;
}
```



## 49.可持久化线段树模板（BZOJ3674：可持久化并查集加强版）



```C++
const int maxm = 10000005, maxn = 200005;
struct node
{
    int l, r, ls, rs, v, deep;
} tr[maxm];
int n, m, sz, rt[maxn], last;
inline void build(int &k, int l, int r)
{
    if (!k)k = ++sz;
    tr[k].l = l;
    tr[k].r = r;
    if (l == r)
    {
        tr[k].v = l;
        return;
    }
    int mid = (l + r) >> 1;
    build(tr[k].ls, l, mid);
    build(tr[k].rs, mid + 1, r);
}
inline int read()
{
    int x=0;char ch=getchar();
    while(ch>'9'||ch<'0')ch=getchar();
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x;
}


inline void update(int l, int r, int x, int &y, int pos, int val)
{
    y = ++sz;
    if (l == r)
    {
        tr[y].v = val;
        return;
    }
    tr[y].ls = tr[x].ls;
    tr[y].rs = tr[x].rs;
    int mid = (l + r) >> 1;
    if (pos <= mid)update(l, mid, tr[x].ls, tr[y].ls, pos, val);
    else update(mid + 1, r, tr[x].rs, tr[y].rs, pos, val);
}
inline int query(int k, int l, int r, int x)
{
    if (l == r)return k;
    int mid = (l + r) >> 1;
    if (x <= mid)return query(tr[k].ls, l, mid, x);
    else return query(tr[k].rs, mid + 1, r, x);
}
inline void add(int k, int l, int r, int pos)
{
    if (l == r)
    {
        tr[k].deep++;
        return;
    }
    int mid = (l + r) >> 1;
    if (pos <= mid)add(tr[k].ls, l, mid, pos);
    else add(tr[k].rs, mid + 1, r, pos);
}
inline int Find(int k, int x)
{
    int p = query(k, 1, n, x);
    if (x == tr[p].v)return p;
    return Find(k, tr[p].v);
}
int main()
{
    n = read();
    m = read();
    build(rt[0], 1, n);
    int f, k, a, b;
    for (int i = 1; i <= m; i++)
    {
        f = read();
        if (f == 1)
        {
            rt[i] = rt[i - 1];
            a = read();
            b = read();
            int p = Find(rt[i], a), q = Find(rt[i], b);
            if (tr[p].v == tr[q].v)continue;
            if (tr[p].deep > tr[q].deep)swap(p, q);
            update(1, n, rt[i - 1], rt[i], tr[p].v, tr[q].v);
            if (tr[p].deep == tr[q].deep)add(rt[i], 1, n, tr[q].v);
        }
        if (f == 2)
        {
            k = read();
            rt[i] = rt[k];
        }
        if (f == 3)
        {
            rt[i] = rt[i - 1];
            a = read();
            b = read();
            int p = Find(rt[i], a), q = Find(rt[i], b);
            if (tr[p].v == tr[q].v)last = 1;
            else last = 0;
            printf("%d\n", last);
        }
    }
    return 0;
}
```



## 50.线段树模板


***

```C++
#define lson l , m , rt << 1
#define rson m + 1 , r , rt << 1 | 1
const int maxn = 222222;
int MAX[maxn<<2];
void PushUP(int rt) {
       MAX[rt] = max(MAX[rt<<1] , MAX[rt<<1|1]);
}
void build(int l,int r,int rt) {
       if (l == r) {
              scanf("%d",&MAX[rt]);
              return ;
       }
       int m = (l + r) >> 1;
       build(lson);
       build(rson);
       PushUP(rt);
}
//updade是点操作query是区间操作，根据不同的需求更换不同的操作
void update(int p,int sc,int l,int r,int rt) {
       if (l == r) {
              MAX[rt] = sc;
              return ;
       }
       int m = (l + r) >> 1;
       if (p <= m) update(p , sc , lson);
       else update(p , sc , rson);
       PushUP(rt);
}
int query(int L,int R,int l,int r,int rt) {
       if (L <= l && r <= R) {
              return MAX[rt];
       }
       int m = (l + r) >> 1;
       int ret = 0;
       if (L <= m) ret = max(ret , query(L , R , lson));
       if (R > m) ret = max(ret , query(L , R , rson));
       return ret;
}
#include <bits/stdc++.h>
using namespace std;
const int INFINITE = INT_MAX;
const int MAXNUM = 1000;
struct SegTreeNode
{
    int val;
    int addMark;//延迟标记
}segTree[MAXNUM];//定义线段树

/*
功能：构建线段树
root：当前线段树的根节点下标
arr: 用来构造线段树的数组
istart：数组的起始位置
iend：数组的结束位置
*/
void build(int root, int arr[], int istart, int iend)
{
    segTree[root].addMark = 0;//----设置标延迟记域
    if(istart == iend)//叶子节点
        segTree[root].val = arr[istart];
    else
    {
        int mid = (istart + iend) / 2;
        build(root*2+1, arr, istart, mid);//递归构造左子树
        build(root*2+2, arr, mid+1, iend);//递归构造右子树
        //根据左右子树根节点的值，更新当前根节点的值
        segTree[root].val = min(segTree[root*2+1].val, segTree[root*2+2].val);
    }
}
/*
功能：当前节点的标志域向孩子节点传递
root: 当前线段树的根节点下标
*/
void pushDown(int root)
{
    if(segTree[root].addMark != 0)
    {
        //设置左右孩子节点的标志域，因为孩子节点可能被多次延迟标记又没有向下传递
        //所以是 “+=”
        segTree[root*2+1].addMark += segTree[root].addMark;
        segTree[root*2+2].addMark += segTree[root].addMark;
        //根据标志域设置孩子节点的值。因为我们是求区间最小值，因此当区间内每个元
        //素加上一个值时，区间的最小值也加上这个值
        segTree[root*2+1].val += segTree[root].addMark;
        segTree[root*2+2].val += segTree[root].addMark;
        //传递后，当前节点标记域清空
        segTree[root].addMark = 0;
    }
}
/*
功能：线段树的区间查询
root：当前线段树的根节点下标

[nstart, nend]: 当前节点所表示的区间
[qstart, qend]: 此次查询的区间

*/
int query(int root, int nstart, int nend, int qstart, int qend)
{
    //查询区间和当前节点区间没有交集
    if(qstart > nend || qend < nstart)
        return INFINITE;
    //当前节点区间包含在查询区间内
    if(qstart <= nstart && qend >= nend)
        return segTree[root].val;
    //分别从左右子树查询，返回两者查询结果的较小值
    pushDown(root); //----延迟标志域向下传递
    int mid = (nstart + nend) / 2;
    return min(query(root*2+1, nstart, mid, qstart, qend),
               query(root*2+2, mid + 1, nend, qstart, qend));

}
/*
功能：更新线段树中某个区间内叶子节点的值
root：当前线段树的根节点下标

[nstart, nend]: 当前节点所表示的区间
[ustart, uend]: 待更新的区间

addVal: 更新的值（原来的值加上addVal）
*/
void update(int root, int nstart, int nend, int ustart, int uend, int addVal)
{
    //更新区间和当前节点区间没有交集
    if(ustart > nend || uend < nstart)
        return ;
    //当前节点区间包含在更新区间内
    if(ustart <= nstart && uend >= nend)
    {
        segTree[root].addMark += addVal;
        segTree[root].val += addVal;
        return ;
    }
    pushDown(root); //延迟标记向下传递
    //更新左右孩子节点
    int mid = (nstart + nend) / 2;
    update(root*2+1, nstart, mid, ustart, uend, addVal);
    update(root*2+2, mid+1, nend, ustart, uend, addVal);
    //根据左右子树的值回溯更新当前节点的值
    segTree[root].val = min(segTree[root*2+1].val, segTree[root*2+2].val);
}
int main()
{
    printf(" ");
    return 0;
}

/**************************************************************************/
//后附各种线段树的操作
//这里以求和为例：
const int MAXM=50000;　　　　　　　　　　//定义 MAXM 为线段最大长度

int a[MAXM+5],st[(MAXM<<2)+5];　　　　// a 数组为 main 函数中读入的内容，st 数组为需要查询的数的信息（如和、最值等），树的空间大小为线段最大长度的四倍

void build(int o,int l,int r){　　　　//传入的参数为 o:当前需要建立的结点；l：当前需要建立的左端点；r：当前需要建立的右端点
    if(l==r)st[o]=a[l];　　　　　　//当左端点等于右端点即建立叶子结点时，直接给数组信息赋值
    else{
        int m=l+((r-l)>>1);　　　　　　// m 为中间点，左儿子结点为 [l,m] ，右儿子结点为 [m+1,r]；
        build(o<<1,l,m);　　　　　　　　//构建左儿子结点
        build((o<<1)|1,m+1,r);　　　　　//构建右儿子结点
        st[o]=st[o<<1]+st[(o<<1)|1];　　//递归返回时用儿子结点更新父节点，此处可进行更新最大值、最小值、区间和等操作
    }
}

{　　　　　　　　　　　　　　　　　　　　　　　//在 main 函数中的语句
        build(1,1,n);
}
//单点修改
.void update(int o,int l,int r,int ind,int ans){　　//o、l、r为当前更新到的结点、左右端点，ind为需要修改的叶子结点左端点，ans为需要修改成的值；
    if(l==r){　　　　　　　　　　　　　　　　　　　　　　//若当前更新点的左右端点相等即到叶子结点时，直接更新信息并返回
        st[o]=ans;
        return;
    }
    int m=l+((r-l)>>1);
    if(ind<=m){　　　　　　　　　　　　　　　　　　　　　　//若需要更新的叶子结点在当前结点的左儿子结点的范围内，则递归更新左儿子结点，否则更新右儿子结点
        update(o<<1,l,m,ind,ans);
    }
    else{
        update((o<<1)|1,m+1,r,ind,ans);
    }
    st[o]=max(st[o<<1],st[(o<<1)|1]);//递归回之后用儿子结点更新父节点（此处是区间最大值）
}

{　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　//在main函数中的语句
        update(1,1,n,ind,ans);
}
//对应单点修改的区间查询
int query(int o,int l,int r,int ql,int qr){　　　　　　//ql、qr为需要查询的区间左右端点
    if(ql>r||qr<l) return -1;　　　　　　　　　　　　　　//若当前结点和需要查找的区间不相交，则返回一个对于区间查询无关的值（如求和时返回0，求最大值时返回-1等）
    if(ql<=l&&qr>=r) return st[o];　　　　　　　　//若当前结点的区间被需要查询的区间覆盖，则返回当前结点的信息
    int m=l+((r-l)>>1);
    int p1=query(o<<1,l,m,ql,qr),p2=query((o<<1)|1,m+1,r,ql,qr);　　//p1为查询左儿子结点得到的信息，p2为查询右儿子结点得到的信息
    return max(p1,p2);　　　　//综合两个儿子结点的信息并返回
}

{　　　　//main函数中的语句
        printf("%d\n",query(1,1,n,a,b));
}
//区间加值
void pushup(int o){　　　　　　　　　　//pushup函数，该函数本身是将当前结点用左右子节点的信息更新，此处求区间和，用于update中将结点信息传递完返回后更新父节点
    st[o]=st[o<<1]+st[o<<1|1];
}

void pushdown(int o,int l,int r){　　//pushdown函数，将o结点的信息传递到左右子节点上
    if(add[o]){　　　　　　　　　　　　　//当父节点有更新信息时才向下传递信息
        add[o<<1]+=add[o];　　　　　　//左右儿子结点均加上父节点的更新值
        add[o<<1|1]+=add[o];
        int m=l+((r-l)>>1);
        st[o<<1]+=add[o]*(m-l+1);　　//左右儿子结点均按照需要加的值总和更新结点信息
        st[o<<1|1]+=add[o]*(r-m);
        add[o]=0;　　　　　　　　　　　　　　　　//信息传递完之后就可以将父节点的更新信息删除
    }
}

void update(int o,int l,int r,int ql,int qr,int addv){　　//ql、qr为需要更新的区间左右端点，addv为需要增加的值
    if(ql<=l&&qr>=r){　　　　　　　　　　　　　　　　　　　　　　//与单点更新一样，当当前结点被需要更新的区间覆盖时
        add[o]+=addv;　　　　　　　　　　　　　　　　　　　　　　//更新该结点的所需更新信息
        st[o]+=addv*(r-l+1);　　　　　　　　　　　　　　　　//更新该结点信息
        return;　　　　　　　　　　　　　　　　　　　　//根据lazy思想，由于不需要遍历到下层结点，因此不需要继续向下更新，直接返回
    }
    

    pushdown(o,l,r);　　　　　　　　　　　　　　　　　　//将当前结点的所需更新信息传递到下一层（其左右儿子结点）
    int m=l+((r-l)>>1);
    if(ql<=m)update(o<<1,l,m,ql,qr,addv);　　　　　//当需更新区间在当前结点的左儿子结点内，则更新左儿子结点
    if(qr>=m+1)update(o<<1|1,m+1,r,ql,qr,addv);　　　//当需更新区间在当前结点的右儿子结点内，则更新右儿子结点
    pushup(o);　　　　　　　　　　　　　　　　　　//递归回上层时一步一步更新回父节点

}

ll query(int o,int l,int r,int ql,int qr){　　　　//ql、qr为需要查询的区间
    if(ql<=l&&qr>=r) return st[o];　　　　　　//若当前结点覆盖区间即为需要查询的区间，则直接返回当前结点的信息
    pushdown(o,l,r);　　　　　　　　　　　　　　　　　　//将当前结点的更新信息传递给其左右子节点
    int m=l+((r-l)>>1);
    ll ans=0;　　　　　　　　　　　　　　　　　　　　　　//所需查询的结果
    if(ql<=m)ans+=query(o<<1,l,m,ql,qr);　　　　　//若所需查询的区间与当前结点的左子节点有交集，则结果加上查询其左子节点的结果
    if(qr>=m+1)ans+=query(o<<1|1,m+1,r,ql,qr);　//若所需查询的区间与当前结点的右子节点有交集，则结果加上查询其右子节点的结果
　　 return ans; 
}
//区间改值
void pushup(int o){
     st[o]=st[o<<1]+st[o<<1|1];
 }

 void pushdown(int o,int l,int r){　　//pushdown和区间加值不同，改值时修改结点信息只需要对修改后的信息求和即可，不用加上原信息
     if(change[o]){
         int c=change[o];
         change[o<<1]=c;
         change[o<<1|1]=c;
         int m=l+((r-l)>>1);
         st[o<<1]=(m-l+1)*c;
         st[o<<1|1]=(r-m)*c;
         change[o]=0;
     }
 }

 void update(int o,int l,int r,int ql,int qr,int c){
     if(ql<=l&&qr>=r){　　　　　　　　　//同样更新结点信息和区间加值不同
         change[o]=c;
         st[o]=(r-l+1)*c;
         return;
     }
     

     pushdown(o,l,r);
     int m=l+((r-l)>>1);
     if(ql<=m)update(o<<1,l,m,ql,qr,c);
     if(qr>=m+1)update(o<<1|1,m+1,r,ql,qr,c);
     pushup(o);

 }

 int query(int o,int l,int r,int ql,int qr){
     if(ql<=l&&qr>=r) return st[o];
     pushdown(o,l,r);
     int m=l+((r-l)>>1);
     int ans=0;
     if(ql<=m)ans+=query(o<<1,l,m,ql,qr);
     if(qr>=m+1)ans+=query(o<<1|1,m+1,r,ql,qr);
     return ans;
 }
```



## 51.重载小于号



```C++
struct Time
{
    int upper, que;
    bool operator < (const Time& t)const{
        if(upper!=t.upper)
        return upper < t.upper;
        else return que > t.que;
    }
};
```

